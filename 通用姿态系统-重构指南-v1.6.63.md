# 通用姿态系统 - 重构指南 v1.6.63

## ? 核心目标

将 `FullBodyPortraitPanel.cs` 重构为支持"通用姿态系统"和"实体化降临"功能。

---

## ?? 重构清单

### 1?? 添加姿态系统字段（在现有字段定义后添加）

```csharp
// ==================== ? 通用姿态系统字段 ====================

/// <summary>
/// 当前覆盖姿态的纹理名称（如 "body_arrival"）
/// 非空时：替代默认身体层 (Layer 1)
/// </summary>
private string overridePosture = null;

/// <summary>
/// 特效纹理名称（如 "glitch_circle"）
/// 绘制在最顶层，使用 Alpha 混合
/// </summary>
private string activeEffect = null;

/// <summary>
/// 动画结束回调
/// </summary>
private Action onAnimationComplete = null;

/// <summary>
/// 动画计时器（秒）
/// </summary>
private float animationTimer = 0f;

/// <summary>
/// 动画总时长（秒）
/// </summary>
private float animationDuration = 0f;

/// <summary>
/// 动画状态标志
/// </summary>
private bool isPlayingAnimation = false;
```

**? 注意：需要在文件顶部添加 `using System;`**

---

### 2?? 添加公共接口方法（在 `FullBodyPortraitPanel` 类中，构造函数后添加）

```csharp
// ==================== ? 通用姿态系统公共接口 ====================

/// <summary>
/// ? 触发姿态动画
/// </summary>
/// <param name="postureName">姿态纹理名称（如 "body_arrival"）</param>
/// <param name="effectName">特效纹理名称（如 "glitch_circle"），可为 null</param>
/// <param name="duration">动画时长（秒）</param>
/// <param name="callback">动画结束回调，可为 null</param>
public void TriggerPostureAnimation(string postureName, string effectName, float duration, Action callback = null)
{
    // 初始化动画状态
    overridePosture = postureName;
    activeEffect = effectName;
    animationDuration = duration;
    animationTimer = 0f;
    onAnimationComplete = callback;
    isPlayingAnimation = true;
    
    Log.Message($"[FullBodyPortraitPanel] ? 开始姿态动画: {postureName}, 特效: {effectName ?? "无"}, 时长: {duration}秒");
}

/// <summary>
/// ? 停止当前动画并恢复默认状态
/// </summary>
public void StopAnimation()
{
    if (!isPlayingAnimation) return;
    
    // 触发回调（如果存在）
    try
    {
        onAnimationComplete?.Invoke();
    }
    catch (Exception ex)
    {
        Log.Error($"[FullBodyPortraitPanel] 动画回调异常: {ex}");
    }
    
    // 清除动画状态
    overridePosture = null;
    activeEffect = null;
    animationTimer = 0f;
    animationDuration = 0f;
    onAnimationComplete = null;
    isPlayingAnimation = false;
    
    Log.Message("[FullBodyPortraitPanel] ? 动画已停止");
}
```

---

### 3?? 修改 `Draw()` 方法（添加动画更新）

在 `Draw()` 方法的**开头**添加：

```csharp
public void Draw()
{
    // ? 更新动画计时器
    UpdateAnimation();
    
    // 更新张嘴动画
    MouthAnimationSystem.Update(Time.deltaTime);
    
    // ...existing code...
}
```

并添加辅助方法：

```csharp
/// <summary>
/// ? 更新动画状态（每帧调用）
/// </summary>
private void UpdateAnimation()
{
    if (!isPlayingAnimation) return;
    
    // 计时器递增
    animationTimer += Time.deltaTime;
    
    // 检查是否结束
    if (animationTimer >= animationDuration)
    {
        StopAnimation();
    }
}
```

---

### 4?? 修改 `DrawPortraitContents()` 方法

#### 修改点 1：Alpha 值计算

将以下代码：

```csharp
float alpha = 1.0f;
bool shouldConsumeInput = false;

if (mouseOver && !shiftHeld)
{
    alpha = 0.2f;
    shouldConsumeInput = false;
}
else
{
    alpha = 1.0f;
    shouldConsumeInput = shiftHeld && mouseOver;
}
```

替换为：

```csharp
float alpha = 1.0f;
bool shouldConsumeInput = false;

// ? 动画中强制不透明（忽略 Shift 逻辑）
if (isPlayingAnimation)
{
    alpha = CalculateAnimationAlpha();
    shouldConsumeInput = false; // 动画中不响应输入
}
else if (mouseOver && !shiftHeld)
{
    alpha = 0.2f;
    shouldConsumeInput = false;
}
else
{
    alpha = 1.0f;
    shouldConsumeInput = shiftHeld && mouseOver;
}
```

#### 修改点 2：呼吸动画控制

将：

```csharp
float breathingOffset = ExpressionSystem.GetBreathingOffset(currentPersona.defName);
```

替换为：

```csharp
// 应用呼吸动画偏移（动画中禁用呼吸动画）
float breathingOffset = isPlayingAnimation ? 0f : ExpressionSystem.GetBreathingOffset(currentPersona.defName);
```

#### 修改点 3：添加特效层绘制

在 `DrawLayeredPortraitRuntime(animatedRect, currentPersona);` **之后**添加：

```csharp
// ? 绘制特效层（最顶层）
if (!string.IsNullOrEmpty(activeEffect))
{
    DrawEffectLayer(animatedRect);
}
```

#### 修改点 4：交互处理条件

将：

```csharp
if (shiftHeld && mouseOver)
```

替换为：

```csharp
if (!isPlayingAnimation && shiftHeld && mouseOver)
```

并将 else 块的注释改为：

```csharp
else
{
    // 未按 Shift 或动画中：取消触摸模式
    // ...existing code...
}
```

#### 修改点 5：工具提示条件

将：

```csharp
if (mouseOver)
{
    string tooltip = BuildTooltip(shiftHeld);
    TooltipHandler.TipRegion(drawRect, tooltip);
}
```

替换为：

```csharp
if (mouseOver && !isPlayingAnimation)
{
    string tooltip = BuildTooltip(shiftHeld);
    TooltipHandler.TipRegion(drawRect, tooltip);
}
```

---

### 5?? 添加辅助方法（在 `DrawPortraitContents()` 之后）

```csharp
/// <summary>
/// ? 计算动画 Alpha 值（淡入/保持/淡出）
/// </summary>
private float CalculateAnimationAlpha()
{
    if (!isPlayingAnimation || animationDuration <= 0f)
    {
        return 1.0f;
    }
    
    float progress = animationTimer / animationDuration;
    
    // 淡入阶段（0 - 10%）
    if (progress < 0.1f)
    {
        return Mathf.Lerp(0f, 1f, progress / 0.1f);
    }
    // 保持阶段（10% - 90%）
    else if (progress < 0.9f)
    {
        return 1.0f;
    }
    // 淡出阶段（90% - 100%）
    else
    {
        return Mathf.Lerp(1f, 0f, (progress - 0.9f) / 0.1f);
    }
}

/// <summary>
/// ? 绘制特效层（最顶层，Alpha 混合）
/// </summary>
private void DrawEffectLayer(Rect rect)
{
    if (string.IsNullOrEmpty(activeEffect) || currentPersona == null) return;
    
    // 加载特效纹理
    string effectPath = $"UI/Narrators/Descent/Effects/{activeEffect}";
    Texture2D effectTexture = ContentFinder<Texture2D>.Get(effectPath, false);
    
    if (effectTexture == null)
    {
        Log.Warning($"[FullBodyPortraitPanel] 特效纹理未找到: {effectPath}");
        return;
    }
    
    // 计算特效 Alpha（脉冲效果）
    float effectAlpha = 0.5f + 0.5f * Mathf.Sin(animationTimer * 3f);
    
    // 应用特效颜色
    Color originalColor = GUI.color;
    GUI.color = new Color(1f, 1f, 1f, effectAlpha * GUI.color.a);
    
    // 绘制特效
    Widgets.DrawTextureFitted(rect, effectTexture, 1.0f);
    
    // 恢复颜色
    GUI.color = originalColor;
}
```

---

### 6?? 修改 `DrawLayeredPortraitRuntime()` 方法（姿态覆盖支持）

**关键修改：在方法开头添加姿态检查**

在 `DrawLayeredPortraitRuntime()` 方法的**最开头**（Layer 1 之前）添加：

```csharp
private void DrawLayeredPortraitRuntime(Rect rect, NarratorPersonaDef persona)
{
    // ==================== ? Layer 1: 身体层（姿态覆盖或默认） ====================
    
    if (!string.IsNullOrEmpty(overridePosture))
    {
        // ? 动画中：绘制姿态纹理（完全替代身体层）
        string posturePath = $"UI/Narrators/Descent/Postures/{overridePosture}";
        Texture2D postureTexture = ContentFinder<Texture2D>.Get(posturePath, false);
        
        if (postureTexture != null)
        {
            Widgets.DrawTextureFitted(rect, postureTexture, 1.0f);
        }
        else
        {
            Log.Warning($"[FullBodyPortraitPanel] 姿态纹理未找到: {posturePath}");
            // 降级：绘制默认身体层
            if (cachedBodyBase != null)
            {
                Widgets.DrawTextureFitted(rect, cachedBodyBase, 1.0f);
            }
            else
            {
                Widgets.DrawBoxSolid(rect, persona.primaryColor);
            }
        }
        
        // ? 姿态动画中：跳过眼睛和嘴巴（特殊姿态自带表情）
        return;
    }
    else
    {
        // ? 平时：绘制默认身体层
        if (cachedBodyBase == null)
        {
            Widgets.DrawBoxSolid(rect, persona.primaryColor);
            return;
        }
        
        Widgets.DrawTextureFitted(rect, cachedBodyBase, 1.0f);
    }
    
    // ==================== Layer 2: 嘴巴层（动态加载，张嘴动画） ====================
    // ...existing code for mouth layer...
    
    // ==================== Layer 3: 眼睛层（动态加载，眨眼动画） ====================
    // ...existing code for eye layer...
    
    // ==================== Layer 4: 特效层（可选：腮红等） ====================
    // ...existing code for flush layer...
}
```

**?? 重要提示：** 
- 删除原有的 `// Layer 1: 身体基础层（缓存）` 部分（因为我们已经重写）
- 保留 Layer 2/3/4 的代码不变

---

## ?? 使用方法（开发者参考）

### 调用示例：

```csharp
// 获取立绘面板实例
var panel = PortraitOverlaySystem.GetPortraitPanel();

// 触发降临动画（3秒，带特效）
panel.TriggerPostureAnimation(
    postureName: "body_arrival",      // 姿态纹理
    effectName: "glitch_circle",      // 特效纹理
    duration: 3.0f,                   // 动画时长
    callback: () => {                 // 动画结束回调
        Log.Message("降临动画完成！");
    }
);

// 手动停止动画
panel.StopAnimation();
```

---

## ?? 纹理文件结构

需要准备以下纹理资源：

```
Textures/
└── UI/
    └── Narrators/
        └── Descent/
            ├── Postures/           # 姿态纹理文件夹
            │   ├── body_arrival.png   # 降临姿态（1024x1574）
            │   ├── body_idle.png      # 待机姿态
            │   └── ...
            └── Effects/            # 特效纹理文件夹
                ├── glitch_circle.png  # 光圈特效
                ├── light_burst.png    # 光爆特效
                └── ...
```

---

## ? 测试清单

- [ ] 编译通过（无错误）
- [ ] 正常模式下立绘显示正常（无姿态覆盖）
- [ ] 调用 `TriggerPostureAnimation` 后姿态正确显示
- [ ] 动画 Alpha 淡入/淡出效果正常
- [ ] 特效层正确显示并有脉冲效果
- [ ] 动画结束回调正确触发
- [ ] 动画中禁用交互（不响应 Shift + 鼠标）
- [ ] 动画中禁用呼吸动画（避免冲突）
- [ ] `StopAnimation()` 正确清除状态

---

## ?? 下一步计划

完成本次重构后，您可以继续实现：

1. **`NarratorDescentSystem.cs`** - 降临系统主控制器
2. **`DescentAnimationController.cs`** - 动画序列控制器
3. **`DescentEffectRenderer.cs`** - 特效渲染器

这些模块将调用 `TriggerPostureAnimation()` 来实现完整的"实体化降临"功能。

---

## ?? 版本历史

- **v1.6.63** - 初始版本（通用姿态系统重构指南）
