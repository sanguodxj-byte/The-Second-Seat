# ?? 表情切换只有轻微变化问题 - 完整诊断报告

**版本**: v1.6.9  
**日期**: 2025-01-15  
**状态**: ?? **诊断中**

---

## ?? 问题现象

### 用户反馈

**原始描述**：
> "表情切换有问题，提示加载成功并且确实有加载到文件，但图像只是略微变化"

**关键观察**：
1. ? 日志显示加载成功
2. ? 确实加载了文件
3. ? 图像只有轻微变化（不明显）
4. ? 表情效果不如预期

---

## ?? 诊断分析

### 可能原因 1：缓存问题

**代码位置**：`PortraitLoader.cs` 第 66-73 行

```csharp
// 1. 检查缓存（包含表情后缀）
string cacheKey = def.defName + expressionSuffix;
if (cache.TryGetValue(cacheKey, out Texture2D cached))
{
    Log.Message($"[PortraitLoader] ? 使用缓存: {cacheKey}");
    return cached;  // ? 问题：即使调用了 ClearCache，可能立即又缓存了旧图
}
```

**分析**：
- `NarratorScreenButton` 调用了 `ClearPortraitCache`
- 但清除后立即调用 `LoadPortrait`
- `LoadPortrait` 第一步就检查缓存
- **可能导致**：清除了旧缓存，但又立即加载并缓存了相同的图

---

### 可能原因 2：表情图片差异太小

**问题**：
- 表情图片本身变化不明显
- 例如：`happy.png` 和 `neutral.png` 只有嘴角轻微上扬
- 导致视觉效果不明显

**验证方法**：
```
1. 打开 Textures\UI\Narrators\9x16\Expressions\Cassandra\
2. 对比 happy.png 和 neutral.png
3. 检查差异是否明显
```

---

### 可能原因 3：面部覆盖合成失败

**代码位置**：`LoadWithFaceOverlay` 方法

**问题**：
- 如果使用面部覆盖模式（`happy_face.png`）
- 合成位置不正确
- 导致表情变化不明显

**日志特征**：
```
[PortraitLoader] ? 使用面部覆盖模式: Cassandra + happy_face
```

---

### 可能原因 4：自动分割合成失败

**代码位置**：`LoadWithAutoSplit` 方法（第 130-187 行）

**问题**：
- 自动分割只处理了头部和服装
- **没有处理表情部分**
- 导致表情始终是 base.png 的表情

**关键代码**：
```csharp
// 2. ? 修改：加载表情部分（分离缓存，不影响）
Texture2D expressionTexture = null;
if (expression.HasValue && expression.Value != ExpressionType.Neutral)
{
    string expressionSuffix = ExpressionSystem.GetExpressionSuffix(expression.Value);
    string expressionFileName = expressionSuffix.TrimStart('_').ToLower();
    string personaName = GetPersonaFolderName(def);
    string expressionPath = $"{EXPRESSIONS_PATH}{personaName}/{expressionFileName}";
    
    expressionTexture = ContentFinder<Texture2D>.Get(expressionPath, false);
    
    if (expressionTexture != null)
    {
        Log.Message($"[PortraitLoader] ? 加载表情层: {expressionPath}");
    }
}
```

**问题**：加载了 `expressionTexture`，但**没有使用**！

---

### 可能原因 5：PortraitSplitter.ComposePortrait 实现问题

**代码位置**：第 176-180 行

```csharp
// 5. 使用自动分割合成
var result = PortraitSplitter.ComposePortrait(
    baseTexture,
    expressionTexture,
    outfitTexture,
    def.defName
);
```

**问题**：
- `PortraitSplitter.ComposePortrait` 可能没有正确处理表情层
- 或者表情层被基础层覆盖了

---

## ?? 修复方案

### 方案 1：强制清除缓存并重新加载

**修改文件**：`PortraitLoader.cs`

**步骤 1**：修改缓存检查逻辑

```csharp
public static Texture2D LoadPortrait(NarratorPersonaDef def, ExpressionType? expression = null)
{
    // ... 前面的代码 ...
    
    // ? 移除：立即返回缓存
    // if (cache.TryGetValue(cacheKey, out Texture2D cached))
    // {
    //     return cached;
    // }
    
    // ? 新增：检查缓存，但允许强制刷新
    bool forceReload = false;
    if (cache.TryGetValue(cacheKey, out Texture2D cached) && !forceReload)
    {
        Log.Message($"[PortraitLoader] ? 使用缓存: {cacheKey}");
        return cached;
    }
    
    // ... 后续加载逻辑 ...
}
```

**步骤 2**：添加强制刷新方法

```csharp
/// <summary>
/// ? 强制刷新特定人格的特定表情
/// </summary>
public static Texture2D LoadPortraitForceRefresh(NarratorPersonaDef def, ExpressionType expression)
{
    // 1. 清除旧缓存
    ClearPortraitCache(def.defName, expression);
    
    // 2. 强制重新加载
    return LoadPortrait(def, expression);
}
```

---

### 方案 2：诊断日志增强

**添加详细日志**，帮助诊断问题：

```csharp
public static Texture2D LoadPortrait(NarratorPersonaDef def, ExpressionType? expression = null)
{
    // ... 前面的代码 ...
    
    // ? 详细日志
    Log.Message($"[PortraitLoader] ========== 开始加载 ==========");
    Log.Message($"[PortraitLoader] 人格: {def.defName}");
    Log.Message($"[PortraitLoader] 表情: {expression?.ToString() ?? "Neutral"}");
    Log.Message($"[PortraitLoader] 缓存键: {cacheKey}");
    Log.Message($"[PortraitLoader] 缓存状态: {(cache.ContainsKey(cacheKey) ? "已缓存" : "未缓存")}");
    
    // ... 加载逻辑 ...
    
    if (texture != null)
    {
        Log.Message($"[PortraitLoader] ? 加载成功: {texture.width}x{texture.height}");
        Log.Message($"[PortraitLoader] 纹理哈希: {texture.GetHashCode()}");
    }
    
    Log.Message($"[PortraitLoader] ========== 加载完成 ==========");
    
    return texture;
}
```

---

### 方案 3：修复自动分割合成

**问题**：`LoadWithAutoSplit` 加载了表情层但没使用

**修复**：

```csharp
private static Texture2D LoadWithAutoSplit(NarratorPersonaDef def, ExpressionType? expression)
{
    try
    {
        // 1. 加载基础纹理（躯干）
        Texture2D baseTexture = LoadBasePortrait(def);
        if (baseTexture == null)
        {
            return null;
        }
        
        // 2. ? 加载表情层（面部，分离缓存）
        Texture2D expressionTexture = null;
        if (expression.HasValue && expression.Value != ExpressionType.Neutral)
        {
            string expressionSuffix = ExpressionSystem.GetExpressionSuffix(expression.Value);
            string expressionFileName = expressionSuffix.TrimStart('_').ToLower();
            string personaName = GetPersonaFolderName(def);
            string expressionPath = $"{EXPRESSIONS_PATH}{personaName}/{expressionFileName}";
            
            expressionTexture = ContentFinder<Texture2D>.Get(expressionPath, false);
            
            if (expressionTexture != null)
            {
                Log.Message($"[PortraitLoader] ? 加载表情层: {expressionPath}");
            }
            else
            {
                Log.Warning($"[PortraitLoader] ? 未找到表情层: {expressionPath}");
            }
        }
        
        // 3. 加载服装层（可选，分离缓存）
        Texture2D outfitTexture = null;
        string outfitPath = OutfitSystem.GetCurrentOutfitPath(def.defName);
        if (!string.IsNullOrEmpty(outfitPath))
        {
            outfitTexture = ContentFinder<Texture2D>.Get(outfitPath, false);
        }
        
        // 4. ? 如果没有表情层和服装层，直接返回基础纹理
        if (expressionTexture == null && outfitTexture == null)
        {
            Log.Message($"[PortraitLoader] ?? 无表情/服装层，返回基础纹理");
            return baseTexture;
        }
        
        // 5. ? 使用自动分割合成
        var result = PortraitSplitter.ComposePortrait(
            baseTexture,
            expressionTexture,  // ? 确保传入表情层
            outfitTexture,
            def.defName
        );
        
        Log.Message($"[PortraitLoader] ? 自动分割合成: {def.defName} (表情: {expressionTexture != null}, 服装: {outfitTexture != null})");
        
        // ? 验证合成结果
        if (result != null)
        {
            Log.Message($"[PortraitLoader] ? 合成成功: {result.width}x{result.height}, 哈希: {result.GetHashCode()}");
        }
        else
        {
            Log.Error($"[PortraitLoader] ? 合成失败！返回基础纹理");
            return baseTexture;
        }
        
        return result;
    }
    catch (Exception ex)
    {
        Log.Error($"[PortraitLoader] 自动分割失败: {ex}");
        return null;
    }
}
```

---

### 方案 4：验证 PortraitSplitter.ComposePortrait

**检查合成方法是否正确处理表情层**：

```csharp
// PortraitSplitter.cs
public static Texture2D ComposePortrait(
    Texture2D baseTexture,
    Texture2D expressionTexture,
    Texture2D outfitTexture,
    string personaDefName)
{
    if (baseTexture == null)
    {
        Log.Error("[PortraitSplitter] 基础纹理为 null");
        return null;
    }
    
    Log.Message($"[PortraitSplitter] 开始合成:");
    Log.Message($"  - 基础: {baseTexture.width}x{baseTexture.height}");
    Log.Message($"  - 表情: {(expressionTexture != null ? $"{expressionTexture.width}x{expressionTexture.height}" : "无")}");
    Log.Message($"  - 服装: {(outfitTexture != null ? $"{outfitTexture.width}x{outfitTexture.height}" : "无")}");
    
    // ? 创建结果纹理
    Texture2D result = new Texture2D(baseTexture.width, baseTexture.height, TextureFormat.RGBA32, false);
    
    // ? 1. 先绘制基础层
    Color[] basePixels = MakeReadable(baseTexture).GetPixels();
    result.SetPixels(basePixels);
    
    // ? 2. 然后绘制表情层（如果有）
    if (expressionTexture != null)
    {
        Color[] expressionPixels = MakeReadable(expressionTexture).GetPixels();
        Color[] currentPixels = result.GetPixels();
        
        // Alpha 混合
        for (int i = 0; i < currentPixels.Length; i++)
        {
            Color bottom = currentPixels[i];
            Color top = expressionPixels[i];
            float alpha = top.a;
            
            currentPixels[i] = new Color(
                bottom.r * (1 - alpha) + top.r * alpha,
                bottom.g * (1 - alpha) + top.g * alpha,
                bottom.b * (1 - alpha) + top.b * alpha,
                Mathf.Max(bottom.a, top.a)
            );
        }
        
        result.SetPixels(currentPixels);
        Log.Message($"[PortraitSplitter] ? 已混合表情层");
    }
    
    // ? 3. 最后绘制服装层（如果有）
    if (outfitTexture != null)
    {
        Color[] outfitPixels = MakeReadable(outfitTexture).GetPixels();
        Color[] currentPixels = result.GetPixels();
        
        for (int i = 0; i < currentPixels.Length; i++)
        {
            Color bottom = currentPixels[i];
            Color top = outfitPixels[i];
            float alpha = top.a;
            
            currentPixels[i] = new Color(
                bottom.r * (1 - alpha) + top.r * alpha,
                bottom.g * (1 - alpha) + top.g * alpha,
                bottom.b * (1 - alpha) + top.b * alpha,
                Mathf.Max(bottom.a, top.a)
            );
        }
        
        result.SetPixels(currentPixels);
        Log.Message($"[PortraitSplitter] ? 已混合服装层");
    }
    
    result.Apply();
    
    Log.Message($"[PortraitSplitter] ? 合成完成: {result.GetHashCode()}");
    
    return result;
}
```

---

## ?? 测试步骤

### 步骤 1：启用详细日志

1. 部署修复后的代码
2. 启动游戏
3. 打开控制台（Ctrl + Shift + D）

### 步骤 2：触发表情切换

1. 打开好感度调试窗口
2. 修改好感度（触发表情变化）
3. 观察日志输出

### 步骤 3：分析日志

**预期日志**（正常情况）：

```
[PortraitLoader] ========== 开始加载 ==========
[PortraitLoader] 人格: Cassandra_Classic
[PortraitLoader] 表情: Happy
[PortraitLoader] 缓存键: Cassandra_Classic_happy
[PortraitLoader] 缓存状态: 未缓存
[PortraitLoader] ? 自动分割模式成功
[PortraitLoader] ? 加载表情层: UI/Narrators/9x16/Expressions/Cassandra/happy
[PortraitSplitter] 开始合成:
[PortraitSplitter]   - 基础: 1024x1024
[PortraitSplitter]   - 表情: 1024x1024
[PortraitSplitter]   - 服装: 无
[PortraitSplitter] ? 已混合表情层
[PortraitSplitter] ? 合成完成: 12345678
[PortraitLoader] ? 加载成功: 1024x1024
[PortraitLoader] 纹理哈希: 12345678
[PortraitLoader] ========== 加载完成 ==========
[NarratorScreenButton] ? 强制更新头像: Cassandra (Happy)
```

**异常日志**（问题情况）：

```
[PortraitLoader] ========== 开始加载 ==========
[PortraitLoader] 人格: Cassandra_Classic
[PortraitLoader] 表情: Happy
[PortraitLoader] 缓存键: Cassandra_Classic_happy
[PortraitLoader] 缓存状态: 已缓存  ? 问题！立即返回了旧缓存
[PortraitLoader] ? 使用缓存: Cassandra_Classic_happy
[PortraitLoader] ========== 加载完成 ==========
```

---

## ?? 诊断清单

### 缓存问题

- [ ] `ClearPortraitCache` 是否正确清除了缓存？
- [ ] 缓存键是否匹配？
- [ ] 是否立即又加载并缓存了相同的图？

### 表情图片问题

- [ ] 表情图片是否存在？
- [ ] 表情图片变化是否明显？
- [ ] 文件路径是否正确？

### 合成问题

- [ ] 是否加载了表情层？
- [ ] 是否正确合成了表情层？
- [ ] Alpha 通道是否正确？

### 其他问题

- [ ] 纹理格式是否正确（RGBA32）？
- [ ] 纹理尺寸是否一致？
- [ ] 是否有异常捕获隐藏了错误？

---

## ?? 快速修复脚本

创建诊断脚本 `Diagnose-Expression.ps1`：

```powershell
# 表情切换诊断脚本

Write-Host "===== 表情切换诊断 =====" -ForegroundColor Cyan

# 1. 检查表情文件
$expressionsPath = "Textures\UI\Narrators\9x16\Expressions\Cassandra"

if (Test-Path $expressionsPath) {
    Write-Host "? 表情目录存在" -ForegroundColor Green
    
    $files = Get-ChildItem $expressionsPath -Filter "*.png"
    Write-Host "找到 $($files.Count) 个表情文件:" -ForegroundColor Yellow
    
    foreach ($file in $files) {
        Write-Host "  - $($file.Name) ($([math]::Round($file.Length / 1KB, 2)) KB)"
    }
} else {
    Write-Host "? 表情目录不存在: $expressionsPath" -ForegroundColor Red
}

# 2. 检查日志
$logPath = "$env:LOCALAPPDATA" + "Low\Ludeon Studios\RimWorld by Ludeon Studios\Player.log"

if (Test-Path $logPath) {
    Write-Host "`n? 日志文件存在" -ForegroundColor Green
    
    # 提取最近的表情相关日志
    $logs = Get-Content $logPath -Tail 500 | Select-String "PortraitLoader|Expression|NarratorScreenButton"
    
    if ($logs.Count -gt 0) {
        Write-Host "`n最近的表情日志 (最后 20 条):" -ForegroundColor Yellow
        $logs | Select-Object -Last 20 | ForEach-Object {
            Write-Host $_.Line
        }
    } else {
        Write-Host "?? 未找到表情相关日志" -ForegroundColor Yellow
    }
} else {
    Write-Host "? 日志文件不存在" -ForegroundColor Red
}

Write-Host "`n===== 诊断完成 =====" -ForegroundColor Cyan
```

---

## ?? 下一步行动

### 立即执行

1. **运行诊断脚本**
   ```powershell
   .\Diagnose-Expression.ps1
   ```

2. **检查日志**
   - 查看是否有 "使用缓存" 的日志
   - 查看是否加载了表情层
   - 查看是否有合成日志

3. **验证文件**
   - 检查 `Textures\UI\Narrators\9x16\Expressions\Cassandra\happy.png` 是否存在
   - 用图片查看器打开，确认与 `base.png` 有明显差异

### 如果日志显示"使用缓存"

**修复方案**：修改 `LoadPortrait` 方法，在检测到表情变化时强制刷新

### 如果日志显示"未找到表情层"

**修复方案**：检查文件路径和文件名大小写

### 如果日志显示"合成失败"

**修复方案**：检查 `PortraitSplitter.ComposePortrait` 实现

---

**版本**: v1.6.9  
**状态**: ?? **等待日志反馈**  
**优先级**: **高**（影响表情系统核心功能）

?? **请运行诊断脚本并提供日志输出，我们将根据结果进一步修复！**
