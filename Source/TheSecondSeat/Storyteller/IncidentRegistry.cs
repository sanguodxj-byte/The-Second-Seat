using System;
using System.Collections.Generic;
using System.Linq;
using RimWorld;
using Verse;

namespace TheSecondSeat.Storyteller
{
    public enum IncidentCategory
    {
        Vanilla,        // Core and Official DLCs
        TheSecondSeat,  // This mod and AI generated incidents
        OtherMods       // Incidents from other mods
    }

    public struct IncidentInfo
    {
        public string defName;
        public string label;
        public string description;
    }

    [StaticConstructorOnStartup]
    public static class IncidentRegistry
    {
        public static List<IncidentDef> VanillaIncidents = new List<IncidentDef>();
        public static List<IncidentDef> TheSecondSeatIncidents = new List<IncidentDef>();
        public static List<IncidentDef> OtherModIncidents = new List<IncidentDef>();

        // Keep track of dynamically registered AI incidents
        private static HashSet<IncidentDef> aiRegisteredIncidents = new HashSet<IncidentDef>();

        static IncidentRegistry()
        {
            // Initialize automatically on startup
            Initialize();
        }

        public static void Initialize()
        {
            VanillaIncidents.Clear();
            TheSecondSeatIncidents.Clear();
            OtherModIncidents.Clear();

            foreach (IncidentDef def in DefDatabase<IncidentDef>.AllDefs)
            {
                ClassifyAndAdd(def);
            }

            Log.Message($"[The Second Seat] IncidentRegistry initialized. Vanilla: {VanillaIncidents.Count}, TSS: {TheSecondSeatIncidents.Count}, Others: {OtherModIncidents.Count}");
        }

        private static void ClassifyAndAdd(IncidentDef def)
        {
            // 1. Check if it is an AI registered incident
            if (aiRegisteredIncidents.Contains(def))
            {
                AddUnique(TheSecondSeatIncidents, def);
                return;
            }

            // 2. Handle Defs with no ModContentPack (usually generated or internal)
            if (def.modContentPack == null)
            {
                // Default to Vanilla if origin is unknown, unless it's explicitly ours
                AddUnique(VanillaIncidents, def);
                return;
            }

            // 3. Classification Logic
            if (def.modContentPack.IsCoreMod || def.modContentPack.IsOfficialMod)
            {
                AddUnique(VanillaIncidents, def);
            }
            else if (IsTheSecondSeat(def.modContentPack))
            {
                AddUnique(TheSecondSeatIncidents, def);
            }
            else
            {
                AddUnique(OtherModIncidents, def);
            }
        }

        private static bool IsTheSecondSeat(ModContentPack pack)
        {
            if (pack == null) return false;
            string pkgId = pack.PackageId.ToLower();
            // Check for known package IDs for this mod
            return pkgId.Contains("thesecondseat") || 
                   pkgId.Contains("the_second_seat") || 
                   pkgId == "rimworld.mod.thesecondseat"; 
        }

        private static void AddUnique(List<IncidentDef> list, IncidentDef def)
        {
            if (!list.Contains(def))
            {
                list.Add(def);
            }
        }

        /// <summary>
        /// Registers a dynamically created AI incident so it is classified correctly.
        /// </summary>
        /// <param name="def">The incident def generated by AI.</param>
        public static void RegisterAIIncident(IncidentDef def)
        {
            if (def == null) return;

            if (!aiRegisteredIncidents.Contains(def))
            {
                aiRegisteredIncidents.Add(def);
                
                // If the registry is already populated, add it immediately to the correct list
                if (TheSecondSeatIncidents.Count > 0 || VanillaIncidents.Count > 0)
                {
                    AddUnique(TheSecondSeatIncidents, def);
                }
            }
        }

        public static List<IncidentDef> GetIncidentsByCategory(IncidentCategory category)
        {
            switch (category)
            {
                case IncidentCategory.Vanilla: return VanillaIncidents;
                case IncidentCategory.TheSecondSeat: return TheSecondSeatIncidents;
                case IncidentCategory.OtherMods: return OtherModIncidents;
                default: return new List<IncidentDef>();
            }
        }

        // --- AI Tools Interface ---

        /// <summary>
        /// Step 1: Get available incident categories.
        /// </summary>
        public static List<string> GetAvailableCategories()
        {
            return Enum.GetNames(typeof(IncidentCategory)).ToList();
        }

        /// <summary>
        /// Step 2: Get list of incidents in a specific category with details.
        /// Supports pagination and searching to minimize token usage.
        /// </summary>
        /// <param name="categoryName">Category: Vanilla, TheSecondSeat, OtherMods</param>
        /// <param name="pageIndex">Page number (0-based)</param>
        /// <param name="pageSize">Items per page (default 20)</param>
        /// <param name="searchTerm">Optional search term for label/defName</param>
        public static List<IncidentInfo> GetIncidentList(string categoryName, int pageIndex = 0, int pageSize = 20, string searchTerm = "")
        {
            if (!Enum.TryParse(categoryName, out IncidentCategory category))
            {
                Log.Warning($"[The Second Seat] Invalid category requested: {categoryName}");
                return new List<IncidentInfo>();
            }

            IEnumerable<IncidentDef> query = GetIncidentsByCategory(category);

            // Filter by search term if provided
            if (!string.IsNullOrEmpty(searchTerm))
            {
                string term = searchTerm.ToLower();
                query = query.Where(d => 
                    (d.defName != null && d.defName.ToLower().Contains(term)) || 
                    (d.label != null && d.label.ToLower().Contains(term)));
            }

            // Pagination
            var pagedDefs = query.Skip(pageIndex * pageSize).Take(pageSize);

            return pagedDefs.Select(d => new IncidentInfo 
            { 
                defName = d.defName, 
                label = d.label, 
                // Truncate description to save tokens if it's too long
                description = !string.IsNullOrEmpty(d.description) && d.description.Length > 100 
                    ? d.description.Substring(0, 97) + "..." 
                    : d.description 
            }).ToList();
        }

        /// <summary>
        /// Step 3: Execute a specific incident by defName.
        /// Targets the current map.
        /// </summary>
        public static bool TryExecuteIncident(string incidentDefName, out string resultMessage)
        {
            IncidentDef def = DefDatabase<IncidentDef>.GetNamedSilentFail(incidentDefName);
            if (def == null)
            {
                resultMessage = $"Incident definition '{incidentDefName}' not found.";
                return false;
            }

            Map map = Find.CurrentMap;
            if (map == null)
            {
                resultMessage = "No active map found to trigger incident.";
                return false;
            }

            try
            {
                IncidentParms parms = StorytellerUtility.DefaultParmsNow(def.category, map);
                
                if (!def.Worker.CanFireNow(parms))
                {
                    resultMessage = $"Incident '{def.label}' cannot fire now (conditions not met).";
                    return false;
                }

                if (def.Worker.TryExecute(parms))
                {
                    resultMessage = $"Successfully executed incident: {def.label}";
                    return true;
                }
                else
                {
                    resultMessage = $"Failed to execute incident: {def.label} (Worker returned false).";
                    return false;
                }
            }
            catch (Exception ex)
            {
                resultMessage = $"Exception triggering incident: {ex.Message}";
                Log.Error($"[The Second Seat] Error triggering incident {incidentDefName}: {ex}");
                return false;
            }
        }
    }
}
