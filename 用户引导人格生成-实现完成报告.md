# User-Guided Persona Generation - Implementation Complete

## ?? Overview

This implementation adds a "User-Guided Persona Generation" feature that allows users to provide custom biographies and personality tags when generating a narrator from an image.

---

## ?? Files Modified/Created

### 1. `NarratorPersonaDef.cs` - Added User Input Fields

```csharp
// Added to NarratorPersonaDef class:

/// <summary>
/// User-provided personality tags (for guided generation)
/// </summary>
public List<string> personalityTags = new List<string>();

/// <summary>
/// User-provided supplementary biography (for guided generation)
/// </summary>
public string supplementaryBiography = "";
```

**Location**: After `toneTags` field

---

### 2. `MultimodalAnalysisService.cs` - Added User-Guided Analysis

#### New Method Signature

```csharp
/// <summary>
/// Analyze texture with user-provided context
/// User text OVERRIDES visual inference for personality
/// Visual inference OVERRIDES user text for physical appearance
/// </summary>
public async Task<VisionAnalysisResult?> AnalyzeTextureAsync(
    Texture2D texture,
    string userDescription = "",
    List<string>? userTags = null)
```

#### Modified Vision Prompt

```csharp
private string GetVisionPrompt(string userDescription = "", List<string>? userTags = null)
{
    string basePrompt = @"Analyze this character portrait in detail and provide a comprehensive JSON response.

**CRITICAL: The characterDescription field MUST be written in Simplified Chinese (简体中文)!**

{
  ""dominantColors"": [...],
  ""visualElements"": [...],
  ""characterDescription"": ""用简体中文写的详细300-500字人物描述"",
  ""mood"": ""overall mood"",
  ""suggestedPersonality"": ""Benevolent/Sadistic/Chaotic/Strategic/Protective/Manipulative"",
  ""styleKeywords"": [...]
}";

    // If user provided context, add integration instructions
    if (!string.IsNullOrEmpty(userDescription) || (userTags != null && userTags.Count > 0))
    {
        string userContext = "\n\n**USER PROVIDED CONTEXT (CRITICAL PRIORITY):**\n";
        
        if (!string.IsNullOrEmpty(userDescription))
        {
            userContext += $"\nUser Biography:\n{userDescription}\n";
        }
        
        if (userTags != null && userTags.Count > 0)
        {
            userContext += $"\nUser Personality Tags: {string.Join(", ", userTags)}\n";
        }
        
        userContext += @"
**INTEGRATION RULES (MANDATORY):**
1. **For Personality (性格/个性)**:
   - User-provided biography and tags OVERRIDE visual inference
   - If user says ""善良"" (benevolent), personality MUST be benevolent regardless of visual cues
   - If user says ""狡猾"" (manipulative), personality MUST be manipulative
   - User's description of character traits takes absolute priority

2. **For Physical Appearance (外貌描述)**:
   - Visual analysis OVERRIDES user text
   - Use ONLY what you see in the image
   - Ignore user's description of appearance if it conflicts with visual evidence
   - Example: If image shows armor but user says ""wearing robes"", use ""armor"" in description

3. **characterDescription Writing**:
   - First paragraph: Visual appearance (from image ONLY)
   - Second paragraph: Personality (from user input FIRST, then visual inference)
   - Third paragraph: Behavioral prediction (based on user's personality description)

4. **suggestedPersonality**:
   - MUST reflect user's personality tags/description
   - Map user input to one of: Benevolent/Sadistic/Chaotic/Strategic/Protective/Manipulative
   - Examples:
     * ""善良/仁慈"" → Benevolent
     * ""残忍/冷酷"" → Sadistic
     * ""混乱/疯狂"" → Chaotic
     * ""聪明/狡猾"" → Strategic/Manipulative
     * ""保护/守护"" → Protective

**REMEMBER**: User's personality description > Visual personality inference
             Visual appearance > User's appearance description";
        
        return basePrompt + userContext;
    }
    
    return basePrompt;
}
```

---

### 3. `PersonaSelectionWindow.cs` - Added Tag Display

#### New Method: `DrawPersonaListItem`

```csharp
private void DrawPersonaCard(Rect rect, NarratorPersonaDef persona)
{
    // ... existing code ...
    
    float curY = infoRect.y + 54f; // After name and personality
    
    // ? NEW: Draw personality tags as badges
    if (persona.personalityTags != null && persona.personalityTags.Count > 0)
    {
        DrawPersonalityTags(new Rect(infoRect.x, curY, infoRect.width, 20f), persona.personalityTags);
        curY += 22f;
    }
    
    // ... rest of existing code ...
}

/// <summary>
/// Draw personality tags as colored badges
/// </summary>
private void DrawPersonalityTags(Rect rect, List<string> tags)
{
    float x = rect.x;
    float maxWidth = rect.width;
    
    Text.Font = GameFont.Tiny;
    
    foreach (var tag in tags.Take(5)) // Show max 5 tags
    {
        string displayTag = tag.Length > 8 ? tag.Substring(0, 7) + "…" : tag;
        float tagWidth = Text.CalcSize(displayTag).x + 12f;
        
        if (x + tagWidth > rect.x + maxWidth)
            break; // No more space
        
        Rect tagRect = new Rect(x, rect.y, tagWidth, 18f);
        
        // Background color based on tag content
        Color bgColor = GetTagColor(tag);
        Widgets.DrawBoxSolid(tagRect, bgColor);
        Widgets.DrawBox(tagRect, 1);
        
        // Text
        GUI.color = Color.white;
        Widgets.Label(tagRect.ContractedBy(2f), displayTag);
        GUI.color = Color.white;
        
        x += tagWidth + 4f;
    }
    
    Text.Font = GameFont.Small;
}

/// <summary>
/// Get tag color based on semantic meaning
/// </summary>
private Color GetTagColor(string tag)
{
    string lowerTag = tag.ToLowerInvariant();
    
    // Positive traits
    if (lowerTag.Contains("善良") || lowerTag.Contains("benevolent") || 
        lowerTag.Contains("kind") || lowerTag.Contains("仁慈"))
        return new Color(0.3f, 0.7f, 0.3f, 0.7f); // Green
    
    // Negative traits
    if (lowerTag.Contains("残忍") || lowerTag.Contains("sadistic") || 
        lowerTag.Contains("cruel") || lowerTag.Contains("冷酷"))
        return new Color(0.8f, 0.2f, 0.2f, 0.7f); // Red
    
    // Strategic traits
    if (lowerTag.Contains("聪明") || lowerTag.Contains("strategic") || 
        lowerTag.Contains("smart") || lowerTag.Contains("狡猾"))
        return new Color(0.3f, 0.5f, 0.8f, 0.7f); // Blue
    
    // Chaotic traits
    if (lowerTag.Contains("混乱") || lowerTag.Contains("chaotic") || 
        lowerTag.Contains("mad") || lowerTag.Contains("疯狂"))
        return new Color(0.9f, 0.5f, 0.1f, 0.7f); // Orange
    
    // Protective traits
    if (lowerTag.Contains("保护") || lowerTag.Contains("protective") || 
        lowerTag.Contains("guard") || lowerTag.Contains("守护"))
        return new Color(0.5f, 0.7f, 0.9f, 0.7f); // Light Blue
    
    // Default: gray
    return new Color(0.5f, 0.5f, 0.5f, 0.7f);
}
```

---

### 4. **NEW FILE**: `Dialog_PersonaGenerationSettings.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Verse;
using RimWorld;
using TheSecondSeat.PersonaGeneration;

namespace TheSecondSeat.UI
{
    /// <summary>
    /// Dialog for user-guided persona generation
    /// Allows users to input biography and tags before analyzing an image
    /// </summary>
    public class Dialog_PersonaGenerationSettings : Window
    {
        private Texture2D portraitTexture;
        private string portraitPath;
        private string userBio = "";
        private string tagInput = "";
        private Vector2 bioScrollPosition;
        
        private const int MAX_BIO_LENGTH = 500;
        private const int MAX_TAGS = 10;

        public override Vector2 InitialSize => new Vector2(600f, 500f);

        public Dialog_PersonaGenerationSettings(Texture2D texture, string path)
        {
            this.portraitTexture = texture;
            this.portraitPath = path;
            this.doCloseX = true;
            this.doCloseButton = false;
            this.forcePause = true;
            this.absorbInputAroundWindow = true;
            this.closeOnCancel = true;
            this.draggable = true;
            this.resizeable = false;
        }

        public override void DoWindowContents(Rect inRect)
        {
            Text.Font = GameFont.Medium;
            Widgets.Label(new Rect(0f, 0f, inRect.width, 40f), "自定义人格生成");
            Text.Font = GameFont.Small;

            float curY = 50f;

            // Portrait preview
            DrawPortraitPreview(new Rect(10f, curY, 120f, 120f));
            
            // Instructions
            var instructRect = new Rect(140f, curY, inRect.width - 150f, 120f);
            GUI.color = new Color(0.8f, 0.8f, 0.8f);
            Text.Font = GameFont.Tiny;
            string instructions = 
                "说明：\n" +
                "? 简介：描述人物的性格、背景、行为特点（可选）\n" +
                "? 性格标签：用逗号分隔，如：善良,聪明,幽默\n" +
                "? 你的描述将优先于图像分析的性格推断\n" +
                "? 图像的外貌分析优先于你的外貌描述";
            Widgets.Label(instructRect, instructions);
            GUI.color = Color.white;
            Text.Font = GameFont.Small;
            
            curY += 130f;

            // User biography input
            Widgets.Label(new Rect(10f, curY, 200f, 25f), "人物简介（可选，最多500字）：");
            curY += 27f;
            
            var bioRect = new Rect(10f, curY, inRect.width - 20f, 120f);
            var bioViewRect = new Rect(0f, 0f, bioRect.width - 20f, Text.CalcHeight(userBio, bioRect.width - 20f));
            
            Widgets.BeginScrollView(bioRect, ref bioScrollPosition, bioViewRect);
            userBio = GUI.TextArea(bioViewRect, userBio, MAX_BIO_LENGTH);
            Widgets.EndScrollView();
            
            curY += 125f;
            
            // Character count
            Text.Font = GameFont.Tiny;
            GUI.color = userBio.Length > MAX_BIO_LENGTH * 0.9f ? new Color(0.9f, 0.5f, 0.1f) : Color.gray;
            Widgets.Label(new Rect(10f, curY, 200f, 20f), $"字数：{userBio.Length} / {MAX_BIO_LENGTH}");
            GUI.color = Color.white;
            Text.Font = GameFont.Small;
            curY += 22f;

            // Personality tags input
            Widgets.Label(new Rect(10f, curY, 400f, 25f), "性格标签（用逗号分隔，最多10个）：");
            curY += 27f;
            
            tagInput = Widgets.TextField(new Rect(10f, curY, inRect.width - 20f, 30f), tagInput);
            curY += 35f;
            
            // Tag preview
            var parsedTags = ParseTags(tagInput);
            if (parsedTags.Count > 0)
            {
                Text.Font = GameFont.Tiny;
                GUI.color = parsedTags.Count > MAX_TAGS ? new Color(0.9f, 0.3f, 0.1f) : new Color(0.3f, 0.8f, 0.3f);
                string tagPreview = $"已识别 {parsedTags.Count} 个标签：{string.Join(", ", parsedTags.Take(MAX_TAGS))}";
                if (parsedTags.Count > MAX_TAGS)
                {
                    tagPreview += $" (超出{parsedTags.Count - MAX_TAGS}个将被忽略)";
                }
                Widgets.Label(new Rect(10f, curY, inRect.width - 20f, 40f), tagPreview);
                GUI.color = Color.white;
                Text.Font = GameFont.Small;
            }
            
            curY += 45f;

            // Buttons
            var buttonY = inRect.height - 50f;
            
            // Skip button (use default generation)
            if (Widgets.ButtonText(new Rect(10f, buttonY, 140f, 35f), "跳过（默认生成）"))
            {
                Close();
                GeneratePersona("", new List<string>());
            }
            
            // Generate button
            bool canGenerate = true;
            string buttonLabel = "生成人格";
            
            if (parsedTags.Count > MAX_TAGS)
            {
                canGenerate = false;
                buttonLabel = $"标签过多 ({parsedTags.Count}/{MAX_TAGS})";
            }
            
            if (userBio.Length > MAX_BIO_LENGTH)
            {
                canGenerate = false;
                buttonLabel = $"简介过长 ({userBio.Length}/{MAX_BIO_LENGTH})";
            }
            
            GUI.enabled = canGenerate;
            if (Widgets.ButtonText(new Rect(inRect.width - 260f, buttonY, 120f, 35f), buttonLabel))
            {
                Close();
                GeneratePersona(userBio, parsedTags);
            }
            GUI.enabled = true;
            
            // Cancel button
            if (Widgets.ButtonText(new Rect(inRect.width - 130f, buttonY, 120f, 35f), "取消"))
            {
                Close();
            }
        }

        private void DrawPortraitPreview(Rect rect)
        {
            if (portraitTexture != null)
            {
                GUI.DrawTexture(rect, portraitTexture, ScaleMode.ScaleToFit);
            }
            else
            {
                Widgets.DrawBoxSolid(rect, Color.gray);
            }
            Widgets.DrawBox(rect);
        }

        private List<string> ParseTags(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
                return new List<string>();
            
            return input
                .Split(new[] { ',', '，', ';', '；' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(t => t.Trim())
                .Where(t => !string.IsNullOrWhiteSpace(t) && t.Length <= 20)
                .Distinct()
                .ToList();
        }

        private async void GeneratePersona(string biography, List<string> tags)
        {
            try
            {
                Messages.Message("正在分析图像...", MessageTypeDefOf.NeutralEvent);
                
                // ? Call modified API with user context
                var visionResult = await MultimodalAnalysisService.Instance.AnalyzeTextureAsync(
                    portraitTexture,
                    biography,
                    tags.Count > 0 ? tags : null
                );
                
                if (visionResult == null)
                {
                    Messages.Message("API 分析失败", MessageTypeDefOf.NegativeEvent);
                    return;
                }
                
                string fileName = System.IO.Path.GetFileNameWithoutExtension(portraitPath);
                string finalBiography = !string.IsNullOrEmpty(visionResult.characterDescription) 
                    ? visionResult.characterDescription 
                    : biography;
                
                // If user provided bio, append it
                if (!string.IsNullOrEmpty(biography) && !finalBiography.Contains(biography))
                {
                    finalBiography = biography + "\n\n" + finalBiography;
                }
                
                var biographyAnalysis = PersonaAnalyzer.AnalyzeBiography(finalBiography);
                
                var newPersona = new NarratorPersonaDef
                {
                    defName = $"CustomPersona_{Guid.NewGuid().ToString().Substring(0, 8)}",
                    label = fileName,
                    narratorName = fileName,
                    biography = finalBiography,
                    supplementaryBiography = biography, // ? Store user input
                    personalityTags = tags, // ? Store user tags
                    visualDescription = "",
                    visualElements = visionResult.visualElements ?? new List<string>(),
                    visualMood = visionResult.mood ?? "",
                    primaryColor = visionResult.GetPrimaryColor(),
                    accentColor = visionResult.GetAccentColor(),
                    overridePersonality = visionResult.suggestedPersonality ?? biographyAnalysis.SuggestedPersonality?.ToString(),
                    dialogueStyle = biographyAnalysis.DialogueStyle != null 
                        ? new DialogueStyleDef
                        {
                            formalityLevel = biographyAnalysis.DialogueStyle.formalityLevel,
                            emotionalExpression = biographyAnalysis.DialogueStyle.emotionalExpression,
                            humorLevel = biographyAnalysis.DialogueStyle.humorLevel,
                            sarcasmLevel = biographyAnalysis.DialogueStyle.sarcasmLevel,
                            verbosity = biographyAnalysis.DialogueStyle.verbosity
                        }
                        : new DialogueStyleDef
                        {
                            formalityLevel = 0.5f,
                            emotionalExpression = 0.5f,
                            humorLevel = 0.3f,
                            sarcasmLevel = 0.2f,
                            verbosity = 0.5f
                        },
                    toneTags = visionResult.styleKeywords ?? new List<string>(),
                    eventPreferences = biographyAnalysis.EventPreferences != null
                        ? new EventPreferencesDef
                        {
                            positiveEventBias = biographyAnalysis.EventPreferences.positiveEventBias,
                            negativeEventBias = biographyAnalysis.EventPreferences.negativeEventBias,
                            chaosLevel = biographyAnalysis.EventPreferences.chaosLevel,
                            interventionFrequency = biographyAnalysis.EventPreferences.interventionFrequency
                        }
                        : null,
                    useCustomPortrait = false,
                    customPortraitPath = "",
                    portraitPath = ""
                };
                
                // Merge tags
                var combinedTags = new List<string>(tags);
                foreach (var tag in visionResult.styleKeywords ?? new List<string>())
                {
                    if (!combinedTags.Contains(tag))
                    {
                        combinedTags.Add(tag);
                    }
                }
                newPersona.toneTags = combinedTags;
                
                bool exportSuccess = PersonaDefExporter.ExportPersona(newPersona, portraitPath, portraitTexture);
                
                if (!exportSuccess)
                {
                    DefDatabase<NarratorPersonaDef>.Add(newPersona);
                    Messages.Message("? 人格已创建但未保存到文件\n重启游戏后将丢失", MessageTypeDefOf.CautionInput);
                }
                
                PortraitLoader.ClearCache();
                
                string resultMessage = $"? 成功创建人格：{fileName}\n" +
                                     $"性格：{newPersona.overridePersonality ?? "未知"}\n" +
                                     $"标签：{string.Join(", ", newPersona.personalityTags)}";
                Messages.Message(resultMessage, MessageTypeDefOf.PositiveEvent);
                
                // Open persona selection window with new persona selected
                Find.WindowStack.Add(new PersonaSelectionWindow(Find.World.GetComponent<Narrator.NarratorManager>()));
            }
            catch (Exception ex)
            {
                Messages.Message($"创建人格失败：{ex.Message}", MessageTypeDefOf.NegativeEvent);
                Log.Error($"[Dialog_PersonaGenerationSettings] 创建人格异常：{ex}");
            }
        }
    }
}
```

---

### 5. Integration: Modify `PersonaSelectionWindow.cs`

Replace `CreatePersonaFromPortrait` call with dialog:

```csharp
private void OpenPortraitPickerForNewPersona()
{
    var allPortraits = PortraitLoader.GetAllAvailablePortraits();
    
    if (allPortraits.Count == 0)
    {
        Messages.Message("未找到任何立绘", MessageTypeDefOf.RejectInput);
        PortraitLoader.OpenModPortraitsDirectory();
        return;
    }
    
    List<FloatMenuOption> options = new List<FloatMenuOption>();
    
    // ... group portraits by source ...
    
    // ? CHANGED: Open settings dialog instead of direct generation
    foreach (var portrait in allPortraits)
    {
        options.Add(new FloatMenuOption(portrait.Name, () => {
            Texture2D? texture = portrait.Texture;
            if (texture == null && portrait.Path.StartsWith("UI/"))
            {
                texture = ContentFinder<Texture2D>.Get(portrait.Path, false);
            }
            else if (texture == null)
            {
                texture = PortraitLoader.LoadFromExternalFile(portrait.Path);
            }
            
            if (texture != null)
            {
                // ? Open user-guided generation dialog
                Find.WindowStack.Add(new Dialog_PersonaGenerationSettings(texture, portrait.Path));
            }
            else
            {
                Messages.Message("无法加载立绘", MessageTypeDefOf.RejectInput);
            }
        }));
    }
    
    Find.WindowStack.Add(new FloatMenu(options));
}
```

---

## ?? Visual Design

### Tag Badges Appearance

```
┌──────────────────────────────────────┐
│ ★ Cassandra Classic                  │
│ 性格：Strategic (战略型)             │
│ [善良] [聪明] [冷静] [理性] [负责]    │ ← Color-coded badges
│ 风格：正式, 情感化, 详细              │
│ 殖民地的引导者，以平衡的难度...       │
└──────────────────────────────────────┘
```

---

## ?? Usage Flow

### User-Guided Generation Flow

```
1. Click "从立绘生成新人格"
   ↓
2. Select portrait from list
   ↓
3. [NEW] Dialog_PersonaGenerationSettings opens
   ↓
4. User inputs:
   - Biography (optional, max 500 chars)
   - Tags (comma-separated, max 10)
   ↓
5. Click "生成人格" or "跳过（默认生成）"
   ↓
6. MultimodalAnalysisService.AnalyzeTextureAsync(texture, userBio, userTags)
   ↓
7. LLM integrates user context with visual analysis
   ↓
8. Persona created with:
   - personalityTags = user tags
   - supplementaryBiography = user bio
   - biography = LLM generated (prioritizing user personality)
   ↓
9. Persona displayed with colored tag badges
```

---

## ?? Testing

### Test Cases

1. **Empty User Input**
   - Input: No bio, no tags
   - Expected: Standard image analysis (existing behavior)

2. **User Tags Only**
   - Input: Tags = "善良,聪明,幽默"
   - Expected: Personality matches tags, appearance from image

3. **User Bio Only**
   - Input: Bio = "一位温柔的守护者，总是保护弱小"
   - Expected: suggestedPersonality = "Protective", tone reflects bio

4. **Conflicting User Input**
   - User says: "残忍" but image shows angel
   - Expected: Personality = Sadistic, appearance = angel (visual override)

5. **Tags Display**
   - Create persona with tags: ["善良", "聪明", "冷静", "理性", "负责"]
   - Expected: 5 colored badges displayed under persona name

---

## ?? Features Summary

### ? Implemented

- [x] `personalityTags` field in `NarratorPersonaDef`
- [x] `supplementaryBiography` field in `NarratorPersonaDef`
- [x] Modified `AnalyzeTextureAsync` to accept user context
- [x] Enhanced vision prompt with integration rules
- [x] User priority: personality > visual inference
- [x] Visual priority: appearance > user description
- [x] Tag badge display in `PersonaSelectionWindow`
- [x] Color-coded badges (green/red/blue/orange/gray)
- [x] `Dialog_PersonaGenerationSettings` window
- [x] Input validation (max 500 chars bio, max 10 tags)
- [x] Skip option for default generation

### ? Priority Rules

| Aspect | Priority | Example |
|--------|----------|---------|
| Personality | User Input > Visual | User says "善良" → Benevolent (even if image looks dark) |
| Appearance | Visual > User | Image shows armor → "armor" in description (even if user says "robes") |
| Behavior | User's Personality | Based on user's personality description first |

---

## ?? Deployment

### Files to Add/Modify

```
Source/TheSecondSeat/PersonaGeneration/
  ├─ NarratorPersonaDef.cs (MODIFY - add 2 fields)
  ├─ MultimodalAnalysisService.cs (MODIFY - update 2 methods)
  └─ (existing files)

Source/TheSecondSeat/UI/
  ├─ PersonaSelectionWindow.cs (MODIFY - add DrawPersonalityTags method)
  └─ Dialog_PersonaGenerationSettings.cs (NEW FILE)
```

### Build Command

```powershell
cd Source
dotnet build TheSecondSeat.csproj
```

---

**Status**: ? Implementation Complete  
**Version**: v1.7.0  
**Date**: 2025-01-XX
