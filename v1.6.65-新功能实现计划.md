# ?? The Second Seat v1.6.65 新功能实现计划

**日期**: 2024-12-22  
**版本**: v1.6.65  
**基于**: v1.6.64

---

## ?? 新功能需求

### 1. RimAgent - LLM 思考链与工具调用

**需求描述**:
- LLM 进行思考后调用工具获取需要的数据
- 实现类似 ReAct (Reasoning + Acting) 模式
- 支持多轮工具调用与推理

**实现方案**:

```csharp
// Source/TheSecondSeat/RimAgent/RimAgent.cs
public class RimAgent
{
    // 思考链
    public async Task<RimAgentResponse> ThinkAndAct(string userQuery)
    {
        var thoughtChain = new List<ThoughtStep>();
        var maxIterations = 5;
        
        for (int i = 0; i < maxIterations; i++)
        {
            // 1. LLM 思考
            var thought = await LLM.Think(userQuery, context, thoughtChain);
            
            // 2. 决定是否需要工具
            if (thought.NeedsTool)
            {
                // 3. 调用工具
                var toolResult = await ExecuteTool(thought.ToolName, thought.ToolArgs);
                thoughtChain.Add(new ThoughtStep(thought, toolResult));
                
                // 4. 继续思考
                continue;
            }
            else
            {
                // 5. 返回最终答案
                return thought.FinalAnswer;
            }
        }
    }
}
```

**可用工具库**:
- `GetColonyStatus()` - 获取殖民地状态
- `GetPawnList()` - 获取殖民者列表
- `GetResourceCount(resourceType)` - 查询资源数量
- `GetWeatherInfo()` - 获取天气信息
- `GetThreatLevel()` - 获取威胁等级

---

### 2. TTS 语音打断机制

**需求描述**:
- 新的语音播放可以打断当前正在播放的语音
- 立即停止旧语音，开始播放新语音
- 清理旧的音频资源

**实现方案**:

```csharp
// Source/TheSecondSeat/TTS/TTSAudioPlayer.cs (修改)
public class TTSAudioPlayer
{
    private AudioSource currentAudioSource;
    private Coroutine currentPlaybackCoroutine;
    
    public void PlayWithInterrupt(AudioClip clip)
    {
        // 1. 停止当前播放
        if (currentAudioSource != null && currentAudioSource.isPlaying)
        {
            currentAudioSource.Stop();
            Log.Message("[TTS] 语音被新语音打断");
        }
        
        // 2. 停止嘴部动画协程
        if (currentPlaybackCoroutine != null)
        {
            StopCoroutine(currentPlaybackCoroutine);
        }
        
        // 3. 清理旧资源
        CleanupOldAudio();
        
        // 4. 播放新语音
        currentAudioSource = audioSource;
        currentPlaybackCoroutine = StartCoroutine(PlayWithMouthAnimation(clip));
    }
}
```

---

### 3. 口型动画速度降低

**需求描述**:
- 进一步降低口型动画的变化速度
- 让嘴部动画更加平滑自然
- 减少频繁张合的视觉疲劳

**实现方案**:

```csharp
// Source/TheSecondSeat/PersonaGeneration/MouthAnimationSystem.cs (修改)
public class MouthAnimationSystem
{
    // v1.6.65: 进一步降低动画速度
    private const float OPEN_SPEED = 0.8f;      // 原 1.5f → 0.8f (降低 47%)
    private const float CLOSE_SPEED = 1.2f;     // 原 2.0f → 1.2f (降低 40%)
    private const float HOLD_DURATION = 0.15f;  // 原 0.1f → 0.15f (增加 50%)
    
    // 平滑插值系数增加
    private const float SMOOTH_FACTOR = 0.08f;  // 原 0.15f → 0.08f (更平滑)
}
```

**对比**:

| 参数 | v1.6.60 | v1.6.64 | v1.6.65 (新) | 变化 |
|------|---------|---------|--------------|------|
| 张嘴速度 | 3.0 | 1.5 | 0.8 | ↓ 47% |
| 闭嘴速度 | 4.0 | 2.0 | 1.2 | ↓ 40% |
| 保持时长 | 0.05s | 0.1s | 0.15s | ↑ 50% |
| 平滑系数 | 0.2 | 0.15 | 0.08 | ↓ 47% |

---

## ??? 实现步骤

### Step 1: 创建 RimAgent 系统

#### 1.1 创建核心类

**文件**: `Source/TheSecondSeat/RimAgent/RimAgent.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Verse;
using RimWorld;

namespace TheSecondSeat.RimAgent
{
    /// <summary>
    /// RimAgent - LLM 驱动的智能代理
    /// 
    /// 核心功能：
    /// - 思考链推理 (ReAct 模式)
    /// - 工具调用与结果整合
    /// - 多轮迭代决策
    /// </summary>
    public class RimAgent
    {
        // 工具注册表
        private readonly Dictionary<string, Func<Dictionary<string, object>, Task<object>>> tools;
        
        // LLM 服务
        private readonly LLM.LLMService llmService;
        
        public RimAgent(LLM.LLMService llm)
        {
            llmService = llm;
            tools = new Dictionary<string, Func<Dictionary<string, object>, Task<object>>>();
            
            // 注册工具
            RegisterTools();
        }
        
        private void RegisterTools()
        {
            tools["GetColonyStatus"] = async (args) => 
            {
                return await Task.FromResult(GetColonyStatus());
            };
            
            tools["GetPawnList"] = async (args) =>
            {
                return await Task.FromResult(GetPawnList());
            };
            
            tools["GetResourceCount"] = async (args) =>
            {
                string resourceType = args["resourceType"] as string;
                return await Task.FromResult(GetResourceCount(resourceType));
            };
            
            // ... 更多工具
        }
        
        /// <summary>
        /// 思考并行动 (ReAct 循环)
        /// </summary>
        public async Task<RimAgentResponse> ThinkAndAct(string userQuery, Map map)
        {
            var thoughtChain = new List<ThoughtStep>();
            var context = BuildContext(map);
            var maxIterations = 5;
            
            for (int i = 0; i < maxIterations; i++)
            {
                Log.Message($"[RimAgent] Iteration {i + 1}/{maxIterations}");
                
                // 1. LLM 思考
                var prompt = BuildThinkingPrompt(userQuery, context, thoughtChain);
                var llmResponse = await llmService.SendMessageAsync(prompt);
                
                // 2. 解析思考结果
                var thought = ParseThought(llmResponse);
                
                if (thought.IsFinalAnswer)
                {
                    // 直接返回答案
                    Log.Message($"[RimAgent] Final answer reached at iteration {i + 1}");
                    return new RimAgentResponse
                    {
                        Answer = thought.Answer,
                        ThoughtChain = thoughtChain,
                        IterationCount = i + 1
                    };
                }
                
                if (thought.NeedsTool)
                {
                    // 3. 执行工具
                    Log.Message($"[RimAgent] Calling tool: {thought.ToolName}");
                    var toolResult = await ExecuteTool(thought.ToolName, thought.ToolArgs);
                    
                    // 4. 记录思考步骤
                    thoughtChain.Add(new ThoughtStep
                    {
                        Thought = thought.Reasoning,
                        Action = thought.ToolName,
                        ActionInput = thought.ToolArgs,
                        Observation = toolResult
                    });
                    
                    // 5. 继续下一轮
                    continue;
                }
                
                // 如果既不是最终答案，也不需要工具，说明LLM出错
                Log.Warning($"[RimAgent] LLM response unclear at iteration {i + 1}");
                break;
            }
            
            // 达到最大迭代次数
            Log.Warning($"[RimAgent] Max iterations reached ({maxIterations})");
            return new RimAgentResponse
            {
                Answer = "抱歉，我无法在有限的思考步骤内得出结论。",
                ThoughtChain = thoughtChain,
                IterationCount = maxIterations
            };
        }
        
        private async Task<object> ExecuteTool(string toolName, Dictionary<string, object> args)
        {
            if (tools.TryGetValue(toolName, out var tool))
            {
                return await tool(args);
            }
            
            throw new Exception($"Unknown tool: {toolName}");
        }
        
        // 工具实现
        private object GetColonyStatus()
        {
            var map = Find.CurrentMap;
            if (map == null) return "No active map";
            
            return new
            {
                colonistCount = map.mapPawns.FreeColonistsCount,
                wealth = map.wealthWatcher.WealthTotal,
                date = GenDate.DateFullStringAt(Find.TickManager.TicksAbs, Find.WorldGrid.LongLatOf(map.Tile))
            };
        }
        
        private object GetPawnList()
        {
            var map = Find.CurrentMap;
            if (map == null) return new List<string>();
            
            return map.mapPawns.FreeColonists
                .Select(p => new { name = p.Name.ToStringShort, health = p.health.summaryHealth.SummaryHealthPercent })
                .ToList();
        }
        
        private object GetResourceCount(string resourceType)
        {
            // 实现资源查询
            return 0;
        }
    }
    
    public class ThoughtStep
    {
        public string Thought { get; set; }
        public string Action { get; set; }
        public Dictionary<string, object> ActionInput { get; set; }
        public object Observation { get; set; }
    }
    
    public class RimAgentResponse
    {
        public string Answer { get; set; }
        public List<ThoughtStep> ThoughtChain { get; set; }
        public int IterationCount { get; set; }
    }
}
```

---

### Step 2: TTS 语音打断机制

**文件**: `Source/TheSecondSeat/TTS/TTSAudioPlayer.cs` (修改)

```csharp
// 在现有 TTSAudioPlayer.cs 中添加

private AudioSource currentAudioSource;
private Coroutine currentPlaybackCoroutine;

/// <summary>
/// v1.6.65: 播放语音（支持打断）
/// </summary>
public void PlayAudioWithInterrupt(AudioClip clip)
{
    try
    {
        // 1. 停止当前播放
        if (currentAudioSource != null && currentAudioSource.isPlaying)
        {
            currentAudioSource.Stop();
            Log.Message("[TTSAudioPlayer] 旧语音被打断");
        }
        
        // 2. 停止嘴部动画协程
        if (currentPlaybackCoroutine != null)
        {
            StopCoroutine(currentPlaybackCoroutine);
            currentPlaybackCoroutine = null;
            
            // 立即关闭嘴巴
            MouthAnimationSystem.Instance?.StopAnimation();
        }
        
        // 3. 清理旧音频文件
        CleanupOldAudioFiles();
        
        // 4. 播放新语音
        if (audioSource == null)
        {
            var go = new GameObject("TTSAudioPlayer");
            audioSource = go.AddComponent<AudioSource>();
            audioSource.spatialBlend = 0f; // 2D sound
        }
        
        audioSource.clip = clip;
        audioSource.Play();
        
        currentAudioSource = audioSource;
        
        // 5. 启动嘴部动画
        currentPlaybackCoroutine = CoroutineUtility.StartCoroutine(
            PlayWithMouthAnimation(clip),
            "TTSPlayback"
        );
        
        Log.Message($"[TTSAudioPlayer] 开始播放新语音，时长: {clip.length:F2}秒");
    }
    catch (Exception ex)
    {
        Log.Error($"[TTSAudioPlayer] 播放失败: {ex.Message}");
    }
}
```

---

### Step 3: 口型动画速度优化

**文件**: `Source/TheSecondSeat/PersonaGeneration/MouthAnimationSystem.cs` (修改)

```csharp
// 在 MouthAnimationSystem.cs 中修改参数

/// <summary>
/// v1.6.65: 进一步降低动画速度，提升自然度
/// </summary>
public class MouthAnimationSystem
{
    // === 动画速度参数 (v1.6.65 优化) ===
    
    /// <summary>
    /// 张嘴速度 (数值越小越慢)
    /// v1.6.60: 3.0 → v1.6.64: 1.5 → v1.6.65: 0.8 (降低 47%)
    /// </summary>
    private const float OPEN_SPEED = 0.8f;
    
    /// <summary>
    /// 闭嘴速度 (数值越小越慢)
    /// v1.6.60: 4.0 → v1.6.64: 2.0 → v1.6.65: 1.2 (降低 40%)
    /// </summary>
    private const float CLOSE_SPEED = 1.2f;
    
    /// <summary>
    /// 张嘴保持时长 (秒)
    /// v1.6.60: 0.05s → v1.6.64: 0.1s → v1.6.65: 0.15s (增加 50%)
    /// </summary>
    private const float HOLD_DURATION = 0.15f;
    
    /// <summary>
    /// 平滑插值系数 (数值越小越平滑)
    /// v1.6.60: 0.2 → v1.6.64: 0.15 → v1.6.65: 0.08 (降低 47%)
    /// </summary>
    private const float SMOOTH_FACTOR = 0.08f;
    
    // ... 其他代码保持不变
}
```

---

## ?? 完整实现文件列表

| 文件 | 类型 | 说明 |
|------|------|------|
| `Source/TheSecondSeat/RimAgent/RimAgent.cs` | 新建 | RimAgent 核心类 |
| `Source/TheSecondSeat/RimAgent/RimAgentPrompts.cs` | 新建 | Prompt 模板 |
| `Source/TheSecondSeat/RimAgent/RimAgentTools.cs` | 新建 | 工具库 |
| `Source/TheSecondSeat/TTS/TTSAudioPlayer.cs` | 修改 | 添加打断机制 |
| `Source/TheSecondSeat/PersonaGeneration/MouthAnimationSystem.cs` | 修改 | 优化动画速度 |

---

## ?? 测试计划

### RimAgent 测试

```csharp
// 测试用例 1: 简单查询
userQuery = "我的殖民地现在有多少人？"
expected = LLM 调用 GetColonyStatus() → 返回殖民者数量

// 测试用例 2: 多步推理
userQuery = "我的木材够建造 10 个床吗？"
expected = 
  1. 调用 GetResourceCount("Wood")
  2. 计算 10 * 木材成本
  3. 返回是否足够

// 测试用例 3: 复杂决策
userQuery = "谁最适合去采矿？"
expected =
  1. 调用 GetPawnList()
  2. 分析每个殖民者的采矿技能
  3. 返回推荐人选
```

### TTS 打断测试

```csharp
// 测试场景
1. 播放第一段语音 (10秒)
2. 2秒后播放第二段语音
3. 验证：第一段语音被停止，第二段语音立即开始
4. 验证：嘴部动画切换到新语音
```

### 口型动画测试

```csharp
// 对比测试
1. 播放相同语音
2. 观察 v1.6.64 vs v1.6.65 动画速度
3. 验证：v1.6.65 更平滑、更自然
```

---

## ?? 预期效果

### RimAgent

? **智能查询**:
```
用户: "我现在有多少银？"
AI: [思考] 需要查询资源数量
    [工具] GetResourceCount("Silver")
    [结果] 你现在有 1500 银
```

? **多步推理**:
```
用户: "我能建造防御塔吗？"
AI: [思考] 需要检查资源和科技
    [工具1] GetResourceCount("Steel")
    [观察] 钢材: 200
    [工具2] GetTechLevel()
    [观察] 已解锁 Turret
    [结论] 可以建造！你有足够的钢材，并且已解锁科技。
```

### TTS 打断

? **流畅切换**:
- 旧语音立即停止
- 新语音无延迟开始
- 嘴部动画同步切换

### 口型动画

? **更自然**:
- 张嘴更慢（0.8 vs 1.5）
- 保持时间更长（0.15s vs 0.1s）
- 过渡更平滑（0.08 vs 0.15）

---

**下一步**: 开始实现这些功能
