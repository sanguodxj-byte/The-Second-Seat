# ?? 测试事件异常触发 - 诊断报告

## ?? 问题描述

**症状**: 测试事件（EventTester中定义的DebugAction事件）在游戏中被异常触发

**可能原因分析**:

### 1. NarratorEventManager自动检测机制

```csharp
// NarratorEventManager.cs - GameComponentTick()
public override void GameComponentTick()
{
    int currentTick = Find.TickManager.TicksGame;
    
    // ?? 问题1：每60 tick检查一次所有事件
    if (currentTick - lastCheckTick >= CHECK_INTERVAL)
    {
        CheckAllEvents();  // 这里会检查所有NarratorEventDef
        lastCheckTick = currentTick;
    }
}
```

**问题**: `NarratorEventManager` 会自动检查 `DefDatabase<NarratorEventDef>` 中的所有事件定义，**包括测试事件**。

### 2. CanTrigger检查逻辑

```csharp
// NarratorEventDef.cs - CanTrigger()
public bool CanTrigger(Map map, Dictionary<string, object> context)
{
    // ? 检查禁用状态
    if (isDisabled) return false;
    
    // ? 检查冷却时间
    if (currentTick - lastTriggeredTick < cooldownTicks) return false;
    
    // ? 检查最小触发间隔
    if (currentTick - lastTriggeredTick < minIntervalTicks) return false;
    
    // ?? 问题2：如果triggers列表为空，这一步会被跳过！
    if (triggers != null && triggers.Count > 0)
    {
        foreach (var trigger in triggers)
        {
            if (!trigger.CheckSafe(map, context))
            {
                return false;
            }
        }
    }
    // ?? triggers为空 → 跳过检查 → 返回true
    
    // ?? 问题3：概率检查可能通过
    if (chance < 1.0f && Rand.Value > chance)
    {
        return false;
    }
    
    return true;  // ?? 最终返回true，事件被触发！
}
```

### 3. 测试事件的XML定义缺陷

假设测试事件的XML定义如下：

```xml
<!-- ?? 问题配置示例 -->
<TheSecondSeat.Framework.NarratorEventDef>
  <defName>TestEvent_Dialogue</defName>
  <eventLabel>测试对话事件</eventLabel>
  <category>Test</category>
  
  <!-- ?? 没有定义triggers！-->
  <!-- triggers为空列表，导致CanTrigger跳过触发器检查 -->
  
  <!-- 概率100% -->
  <chance>1.0</chance>
  
  <!-- ?? 没有设置冷却时间！-->
  <!-- cooldownTicks默认为0，意味着没有冷却 -->
  
  <actions>
    <li Class="TheSecondSeat.Framework.Actions.ShowDialogueAction">
      <dialogueText>这是一个测试事件</dialogueText>
    </li>
  </actions>
</TheSecondSeat.Framework.NarratorEventDef>
```

**结果**:
- `triggers` 为空 → 触发器检查跳过
- `cooldownTicks` = 0 → 没有冷却限制
- `minIntervalTicks` 默认 3600 (1分钟) → 每分钟就能触发一次
- `chance` = 1.0 → 100%触发概率

**最终**: 事件每隔1分钟就会被自动触发！

---

## ? 解决方案

### 方案1: 为测试事件添加专用触发器

```xml
<!-- ? 正确的测试事件定义 -->
<TheSecondSeat.Framework.NarratorEventDef>
  <defName>TestEvent_Dialogue</defName>
  <eventLabel>测试对话事件</eventLabel>
  <category>Test</category>
  
  <!-- ? 添加"永不自动触发"触发器 -->
  <triggers>
    <li Class="TheSecondSeat.Framework.Triggers.NeverTrigger">
      <!-- 这个触发器的Check()永远返回false -->
    </li>
  </triggers>
  
  <!-- 或者使用ManualTriggerOnly触发器 -->
  <triggers>
    <li Class="TheSecondSeat.Framework.Triggers.ManualTriggerOnly" />
  </triggers>
  
  <actions>
    <li Class="TheSecondSeat.Framework.Actions.ShowDialogueAction">
      <dialogueText>这是一个测试事件</dialogueText>
    </li>
  </actions>
</TheSecondSeat.Framework.NarratorEventDef>
```

### 方案2: 使用category过滤

```csharp
// NarratorEventManager.cs - CheckAllEvents()
private void CheckAllEvents()
{
    var allEvents = GetSortedEvents();
    
    foreach (var eventDef in allEvents)
    {
        // ? 跳过测试事件
        if (eventDef.category == "Test" || 
            eventDef.category == "Debug")
        {
            continue;
        }
        
        // ... 其他检查 ...
    }
}
```

### 方案3: 添加isTestEvent标志

```csharp
// NarratorEventDef.cs
public class NarratorEventDef : Def
{
    // ? 新增：标记为测试事件
    public bool isTestEvent = false;
    
    // ...
}
```

```xml
<!-- XML中使用 -->
<TheSecondSeat.Framework.NarratorEventDef>
  <defName>TestEvent_Dialogue</defName>
  <isTestEvent>true</isTestEvent>  <!-- ? 标记为测试事件 -->
  <!-- ... -->
</TheSecondSeat.Framework.NarratorEventDef>
```

```csharp
// CheckAllEvents中跳过
if (eventDef.isTestEvent)
{
    continue;
}
```

### 方案4: 增强CanTrigger检查（推荐）

```csharp
// NarratorEventDef.cs - CanTrigger()
public bool CanTrigger(Map map, Dictionary<string, object> context)
{
    // ? 新增：测试事件永不自动触发
    if (isTestEvent)
    {
        return false;
    }
    
    // ? 新增：没有triggers的事件不自动触发
    if (triggers == null || triggers.Count == 0)
    {
        if (Prefs.DevMode)
        {
            Log.Warning($"[NarratorEventDef] Event '{defName}' has no triggers, auto-trigger blocked");
        }
        return false;
    }
    
    // ... 其他检查 ...
}
```

---

## ??? 立即修复步骤

### 1. 创建NeverTrigger触发器

```csharp
// Source/TheSecondSeat/Framework/Triggers/NeverTrigger.cs
using System.Collections.Generic;
using Verse;

namespace TheSecondSeat.Framework.Triggers
{
    /// <summary>
    /// ? 永不触发触发器 - 用于测试事件
    /// 此触发器的Check()永远返回false，
    /// 确保事件只能通过ForceTriggerEvent()手动触发
    /// </summary>
    public class NeverTrigger : TSSTrigger
    {
        public override bool Check(Map map, Dictionary<string, object> context)
        {
            return false;  // 永远返回false，阻止自动触发
        }
        
        public override bool Validate(out string error)
        {
            error = "";
            return true;
        }
    }
}
```

### 2. 更新测试事件XML定义

```xml
<!-- Defs/TSS_Custom_Events.xml -->
<Defs>
  <TheSecondSeat.Framework.NarratorEventDef>
    <defName>TestEvent_Dialogue</defName>
    <eventLabel>测试对话</eventLabel>
    <category>Test</category>
    
    <!-- ? 添加NeverTrigger触发器 -->
    <triggers>
      <li Class="TheSecondSeat.Framework.Triggers.NeverTrigger" />
    </triggers>
    
    <actions>
      <li Class="TheSecondSeat.Framework.Actions.ShowDialogueAction">
        <dialogueText>这是一个测试对话事件</dialogueText>
      </li>
    </actions>
  </TheSecondSeat.Framework.NarratorEventDef>
  
  <!-- 其他测试事件同样添加NeverTrigger -->
  <TheSecondSeat.Framework.NarratorEventDef>
    <defName>TestEvent_Resource</defName>
    <eventLabel>测试资源生成</eventLabel>
    <category>Test</category>
    
    <triggers>
      <li Class="TheSecondSeat.Framework.Triggers.NeverTrigger" />
    </triggers>
    
    <actions>
      <li Class="TheSecondSeat.Framework.Actions.SpawnResourceAction">
        <resourceType>Steel</resourceType>
        <amount>100</amount>
      </li>
    </actions>
  </TheSecondSeat.Framework.NarratorEventDef>
</Defs>
```

### 3. 增强NarratorEventManager的安全检查

```csharp
// NarratorEventManager.cs - CheckAllEvents()
private void CheckAllEvents()
{
    Map map = Find.CurrentMap;
    if (map == null) return;
    
    UpdateContext();
    
    var allEvents = GetSortedEvents();
    
    foreach (var eventDef in allEvents)
    {
        try
        {
            // ? 跳过高优先级事件（已在高优先级检查中处理）
            if (eventDef.priority >= 100)
            {
                continue;
            }
            
            // ? 新增：跳过测试/调试事件
            if (eventDef.category == "Test" || 
                eventDef.category == "Debug")
            {
                continue;
            }
            
            // ? 新增：跳过没有triggers的事件（防御性编程）
            if (eventDef.triggers == null || eventDef.triggers.Count == 0)
            {
                if (Prefs.DevMode)
                {
                    Log.Warning($"[NarratorEventManager] Event '{eventDef.defName}' has no triggers, skipping auto-check");
                }
                continue;
            }
            
            // 检查是否可触发
            if (eventDef.CanTrigger(map, cachedContext))
            {
                // 触发事件
                TriggerEvent(eventDef, map);
            }
        }
        catch (Exception ex)
        {
            Log.Error($"[NarratorEventManager] Failed to check event '{eventDef.defName}': {ex.Message}");
        }
    }
}
```

---

## ?? 验证清单

- [ ] 创建 `NeverTrigger.cs` 触发器
- [ ] 更新所有测试事件的XML定义（添加NeverTrigger）
- [ ] 修改 `NarratorEventManager.CheckAllEvents()` 跳过Test/Debug category
- [ ] 编译并部署
- [ ] 游戏内验证：
  - [ ] 测试事件不再自动触发
  - [ ] DebugAction手动触发仍然正常
  - [ ] 正常事件不受影响

---

## ?? 预期结果

**修复前**:
```
游戏运行 → NarratorEventManager每60 tick检查 
→ TestEvent_Dialogue没有triggers，CanTrigger()返回true 
→ 每分钟自动触发一次测试事件！
```

**修复后**:
```
游戏运行 → NarratorEventManager每60 tick检查 
→ TestEvent_Dialogue的NeverTrigger.Check()返回false 
→ 测试事件被跳过，不会自动触发
→ 只能通过ForceTriggerEvent()手动触发
```

---

**状态**: ?? 诊断完成  
**下一步**: 应用修复方案
