# 9:16 竖版立绘动态表情系统设计方案

## ?? 方案概述

本方案设计了一套支持 **9:16 竖版立绘** 和 **动态表情** 的完整系统，兼容现有的横版立绘，同时提供灵活的表情切换机制。

---

## ?? 核心设计理念

### 1. 双模式支持
- **横版模式 (16:9)**: 传统横版立绘，适合宽屏显示
- **竖版模式 (9:16)**: 手机竖屏、垂直展示场景

### 2. 三种表情实现方式
```
方式A: 整图替换 (Full Replacement)
  └─ 每个表情一张完整立绘
  └─ 适合：简单场景，表情数量少

方式B: 面部覆盖 (Face Overlay)
  └─ 基础立绘 + 多张面部表情层
  └─ 适合：复杂立绘，节省资源

方式C: 分层合成 (Layered Composition) ?推荐
  └─ 基础立绘 + 多层可替换部件（眼睛、嘴巴、眉毛等）
  └─ 适合：精细控制，最大灵活性
```

---

## ?? 文件结构与命名规范

### 竖版立绘文件夹结构
```
Textures/UI/Narrators/
├─ 9x16/                          # 竖版立绘根目录
│  ├─ Cassandra/                  # 人格名文件夹
│  │  ├─ base.png                 # 基础立绘 (9:16, 推荐 1080x1920)
│  │  │
│  │  ├─ full/                    # 整图替换模式
│  │  │  ├─ happy.png             # 开心表情完整图
│  │  │  ├─ sad.png               # 悲伤表情完整图
│  │  │  └─ angry.png             # 愤怒表情完整图
│  │  │
│  │  ├─ face/                    # 面部覆盖模式
│  │  │  ├─ happy_face.png        # 开心面部 (透明背景)
│  │  │  ├─ sad_face.png          # 悲伤面部
│  │  │  └─ angry_face.png        # 愤怒面部
│  │  │
│  │  └─ layers/                  # 分层合成模式 ?
│  │     ├─ eyes_neutral.png      # 中性眼睛
│  │     ├─ eyes_happy.png        # 开心眼睛
│  │     ├─ eyes_sad.png          # 悲伤眼睛
│  │     ├─ mouth_neutral.png     # 中性嘴巴
│  │     ├─ mouth_smile.png       # 微笑嘴巴
│  │     ├─ eyebrows_normal.png   # 普通眉毛
│  │     └─ eyebrows_angry.png    # 愤怒眉毛
│  │
│  └─ Phoebe/
│     └─ ...
│
└─ 16x9/                          # 横版立绘根目录 (现有系统)
   └─ ...
```

### 命名规范

#### 整图替换模式
```
base.png                          # 基础立绘（中性表情）
{expression}.png                  # 表情名.png
  例如: happy.png, sad.png, angry.png
```

#### 面部覆盖模式
```
base.png                          # 基础立绘（完整身体）
{expression}_face.png             # 表情名_face.png
  例如: happy_face.png, sad_face.png
```

#### 分层合成模式 ?
```
base.png                          # 基础立绘（身体、背景）
eyes_{variant}.png                # 眼睛层
mouth_{variant}.png               # 嘴巴层
eyebrows_{variant}.png            # 眉毛层
blush_{variant}.png               # 腮红层（可选）
special_{variant}.png             # 特殊效果层（可选）

例如:
  eyes_neutral.png, eyes_happy.png, eyes_sad.png
  mouth_neutral.png, mouth_smile.png, mouth_frown.png
  eyebrows_normal.png, eyebrows_raised.png, eyebrows_angry.png
```

---

## ??? 竖版立绘尺寸与区域定义

### 推荐尺寸
```
标准分辨率: 1080 x 1920 (9:16)
高清分辨率: 1440 x 2560 (9:16)
超高清:     2160 x 3840 (9:16)
```

### 面部区域坐标 (9:16 竖版)
```csharp
// 竖版立绘面部区域建议
public class PortraitFaceRegion_9x16 : FaceRegion
{
    public PortraitFaceRegion_9x16()
    {
        CenterX = 0.5f;       // 水平居中
        CenterY = 0.25f;      // 上1/4处（竖版头部通常在上方）
        Width = 0.6f;         // 宽度占60%
        Height = 0.2f;        // 高度占20%
        FeatherRadius = 0.03f;// 羽化3%
    }
}
```

### 分层部件坐标 (相对于面部区域)
```csharp
// 眼睛位置
Eyes = {
    CenterX = 0.5f,       // 面部中心
    CenterY = 0.4f,       // 面部上2/5处
    Width = 0.8f,         // 面部宽度的80%
    Height = 0.3f         // 面部高度的30%
}

// 嘴巴位置
Mouth = {
    CenterX = 0.5f,       // 面部中心
    CenterY = 0.75f,      // 面部下1/4处
    Width = 0.5f,         // 面部宽度的50%
    Height = 0.25f        // 面部高度的25%
}

// 眉毛位置
Eyebrows = {
    CenterX = 0.5f,       // 面部中心
    CenterY = 0.2f,       // 面部上1/5处
    Width = 0.85f,        // 面部宽度的85%
    Height = 0.15f        // 面部高度的15%
}
```

---

## ?? 代码实现

### 1. 立绘纵横比检测器

```csharp
/// <summary>
/// 立绘纵横比类型
/// </summary>
public enum PortraitAspectRatio
{
    Landscape_16x9,   // 横版 16:9
    Portrait_9x16,    // 竖版 9:16
    Square,           // 方形 1:1
    Custom            // 自定义比例
}

/// <summary>
/// 纵横比检测工具
/// </summary>
public static class AspectRatioDetector
{
    /// <summary>
    /// 检测纹理的纵横比类型
    /// </summary>
    public static PortraitAspectRatio DetectAspectRatio(Texture2D texture)
    {
        if (texture == null) return PortraitAspectRatio.Custom;
        
        float aspectRatio = (float)texture.width / texture.height;
        
        // 16:9 ≈ 1.778
        if (Mathf.Abs(aspectRatio - 1.778f) < 0.1f)
            return PortraitAspectRatio.Landscape_16x9;
        
        // 9:16 ≈ 0.5625
        if (Mathf.Abs(aspectRatio - 0.5625f) < 0.1f)
            return PortraitAspectRatio.Portrait_9x16;
        
        // 1:1
        if (Mathf.Abs(aspectRatio - 1.0f) < 0.1f)
            return PortraitAspectRatio.Square;
        
        return PortraitAspectRatio.Custom;
    }
    
    /// <summary>
    /// 获取适配的面部区域
    /// </summary>
    public static FaceRegion GetFaceRegionForAspectRatio(PortraitAspectRatio ratio)
    {
        return ratio switch
        {
            PortraitAspectRatio.Landscape_16x9 => new FaceRegion
            {
                CenterX = 0.5f, CenterY = 0.35f,
                Width = 0.4f, Height = 0.3f,
                FeatherRadius = 0.05f
            },
            
            PortraitAspectRatio.Portrait_9x16 => new FaceRegion
            {
                CenterX = 0.5f, CenterY = 0.25f,
                Width = 0.6f, Height = 0.2f,
                FeatherRadius = 0.03f
            },
            
            PortraitAspectRatio.Square => new FaceRegion
            {
                CenterX = 0.5f, CenterY = 0.4f,
                Width = 0.5f, Height = 0.35f,
                FeatherRadius = 0.04f
            },
            
            _ => new FaceRegion() // 默认区域
        };
    }
}
```

### 2. 分层表情合成器

```csharp
/// <summary>
/// 表情层类型
/// </summary>
public enum ExpressionLayerType
{
    Base,         // 基础层（身体、背景）
    Eyes,         // 眼睛层
    Mouth,        // 嘴巴层
    Eyebrows,     // 眉毛层
    Blush,        // 腮红层
    Special       // 特殊效果层（汗滴、心形等）
}

/// <summary>
/// 表情层定义
/// </summary>
public class ExpressionLayer
{
    public ExpressionLayerType LayerType { get; set; }
    public string Variant { get; set; } = "neutral";  // 变体名（如 "happy", "sad"）
    public Texture2D Texture { get; set; }
    public FaceRegion Region { get; set; }            // 该层的位置区域
    public int ZOrder { get; set; } = 0;              // Z轴顺序（层级）
    public float Opacity { get; set; } = 1.0f;        // 透明度
}

/// <summary>
/// 分层表情合成器
/// </summary>
public static class LayeredExpressionCompositor
{
    /// <summary>
    /// 合成多层表情
    /// </summary>
    public static Texture2D CompositeLayers(
        Texture2D baseTexture,
        List<ExpressionLayer> layers,
        string cacheKey = null)
    {
        try
        {
            // 创建结果纹理
            Texture2D result = new Texture2D(
                baseTexture.width, 
                baseTexture.height, 
                TextureFormat.RGBA32, 
                false);
            
            // 复制基础纹理
            Texture2D readableBase = MakeReadable(baseTexture);
            Color[] pixels = readableBase.GetPixels();
            result.SetPixels(pixels);
            
            // 按 Z 轴顺序排序层
            var sortedLayers = layers.OrderBy(l => l.ZOrder).ToList();
            
            // 逐层合成
            foreach (var layer in sortedLayers)
            {
                if (layer.Texture == null) continue;
                
                BlendLayer(result, layer);
            }
            
            result.Apply();
            
            // 清理临时纹理
            UnityEngine.Object.Destroy(readableBase);
            
            Log.Message($"[LayeredCompositor] 合成 {layers.Count} 层表情");
            return result;
        }
        catch (Exception ex)
        {
            Log.Error($"[LayeredCompositor] 合成失败: {ex}");
            return baseTexture;
        }
    }
    
    /// <summary>
    /// 混合单个图层
    /// </summary>
    private static void BlendLayer(Texture2D target, ExpressionLayer layer)
    {
        Texture2D readableLayer = MakeReadable(layer.Texture);
        Rect region = layer.Region.GetPixelRect(target.width, target.height);
        
        int startX = Mathf.Max(0, Mathf.FloorToInt(region.x));
        int startY = Mathf.Max(0, Mathf.FloorToInt(region.y));
        int endX = Mathf.Min(target.width, Mathf.CeilToInt(region.xMax));
        int endY = Mathf.Min(target.height, Mathf.CeilToInt(region.yMax));
        
        for (int y = startY; y < endY; y++)
        {
            for (int x = startX; x < endX; x++)
            {
                // 计算 UV 坐标
                float u = (x - region.x) / region.width;
                float v = (y - region.y) / region.height;
                
                if (u < 0 || u > 1 || v < 0 || v > 1) continue;
                
                // 采样层纹理
                int layerX = Mathf.FloorToInt(u * readableLayer.width);
                int layerY = Mathf.FloorToInt(v * readableLayer.height);
                
                if (layerX < 0 || layerX >= readableLayer.width || 
                    layerY < 0 || layerY >= readableLayer.height) continue;
                
                Color layerColor = readableLayer.GetPixel(layerX, layerY);
                
                // 跳过完全透明的像素
                if (layerColor.a < 0.01f) continue;
                
                // Alpha 混合
                Color baseColor = target.GetPixel(x, y);
                float alpha = layerColor.a * layer.Opacity;
                Color blended = Color.Lerp(baseColor, layerColor, alpha);
                
                target.SetPixel(x, y, blended);
            }
        }
        
        UnityEngine.Object.Destroy(readableLayer);
    }
    
    private static Texture2D MakeReadable(Texture2D source)
    {
        RenderTexture renderTex = RenderTexture.GetTemporary(
            source.width, source.height, 0, 
            RenderTextureFormat.Default, RenderTextureReadWrite.Linear);
        
        Graphics.Blit(source, renderTex);
        RenderTexture previous = RenderTexture.active;
        RenderTexture.active = renderTex;
        
        Texture2D readable = new Texture2D(source.width, source.height, TextureFormat.RGBA32, false);
        readable.ReadPixels(new Rect(0, 0, renderTex.width, renderTex.height), 0, 0);
        readable.Apply();
        
        RenderTexture.active = previous;
        RenderTexture.ReleaseTemporary(renderTex);
        
        return readable;
    }
}
```

### 3. 增强的立绘加载器

```csharp
/// <summary>
/// 加载竖版立绘（支持 9:16）
/// </summary>
public static Texture2D LoadPortrait_9x16(
    NarratorPersonaDef def, 
    ExpressionType expression)
{
    string personaName = def.defName;
    
    // 1. 尝试加载基础立绘
    Texture2D baseTex = LoadBaseTexture_9x16(personaName);
    if (baseTex == null)
    {
        Log.Warning($"[PortraitLoader] 未找到竖版基础立绘: {personaName}");
        return null;
    }
    
    // 2. 检测使用哪种表情模式
    ExpressionMode mode = DetectExpressionMode(personaName);
    
    // 3. 根据模式加载表情
    return mode switch
    {
        ExpressionMode.FullReplacement => 
            LoadFullExpression_9x16(personaName, expression) ?? baseTex,
        
        ExpressionMode.FaceOverlay => 
            LoadWithFaceOverlay_9x16(baseTex, personaName, expression),
        
        ExpressionMode.LayeredComposition => 
            LoadWithLayers_9x16(baseTex, personaName, expression),
        
        _ => baseTex
    };
}

/// <summary>
/// 加载分层表情
/// </summary>
private static Texture2D LoadWithLayers_9x16(
    Texture2D baseTexture,
    string personaName,
    ExpressionType expression)
{
    var layers = new List<ExpressionLayer>();
    
    // 获取表情配置
    var config = GetExpressionLayerConfig(expression);
    
    // 加载眼睛层
    if (!string.IsNullOrEmpty(config.EyesVariant))
    {
        var eyesTex = LoadLayerTexture(personaName, "eyes", config.EyesVariant);
        if (eyesTex != null)
        {
            layers.Add(new ExpressionLayer
            {
                LayerType = ExpressionLayerType.Eyes,
                Variant = config.EyesVariant,
                Texture = eyesTex,
                Region = GetLayerRegion(ExpressionLayerType.Eyes),
                ZOrder = 10
            });
        }
    }
    
    // 加载嘴巴层
    if (!string.IsNullOrEmpty(config.MouthVariant))
    {
        var mouthTex = LoadLayerTexture(personaName, "mouth", config.MouthVariant);
        if (mouthTex != null)
        {
            layers.Add(new ExpressionLayer
            {
                LayerType = ExpressionLayerType.Mouth,
                Variant = config.MouthVariant,
                Texture = mouthTex,
                Region = GetLayerRegion(ExpressionLayerType.Mouth),
                ZOrder = 11
            });
        }
    }
    
    // 加载眉毛层
    if (!string.IsNullOrEmpty(config.EyebrowsVariant))
    {
        var eyebrowsTex = LoadLayerTexture(personaName, "eyebrows", config.EyebrowsVariant);
        if (eyebrowsTex != null)
        {
            layers.Add(new ExpressionLayer
            {
                LayerType = ExpressionLayerType.Eyebrows,
                Variant = config.EyebrowsVariant,
                Texture = eyebrowsTex,
                Region = GetLayerRegion(ExpressionLayerType.Eyebrows),
                ZOrder = 9
            });
        }
    }
    
    // 合成所有层
    if (layers.Count > 0)
    {
        return LayeredExpressionCompositor.CompositeLayers(
            baseTexture, 
            layers, 
            $"{personaName}_{expression}_9x16");
    }
    
    return baseTexture;
}

/// <summary>
/// 获取表情层配置
/// </summary>
private static ExpressionLayerConfig GetExpressionLayerConfig(ExpressionType expression)
{
    return expression switch
    {
        ExpressionType.Happy => new ExpressionLayerConfig
        {
            EyesVariant = "happy",
            MouthVariant = "smile",
            EyebrowsVariant = "raised"
        },
        
        ExpressionType.Sad => new ExpressionLayerConfig
        {
            EyesVariant = "sad",
            MouthVariant = "frown",
            EyebrowsVariant = "droopy"
        },
        
        ExpressionType.Angry => new ExpressionLayerConfig
        {
            EyesVariant = "narrow",
            MouthVariant = "frown",
            EyebrowsVariant = "angry"
        },
        
        // ... 更多表情配置
        
        _ => new ExpressionLayerConfig
        {
            EyesVariant = "neutral",
            MouthVariant = "neutral",
            EyebrowsVariant = "normal"
        }
    };
}

/// <summary>
/// 表情层配置
/// </summary>
public class ExpressionLayerConfig
{
    public string EyesVariant { get; set; } = "";
    public string MouthVariant { get; set; } = "";
    public string EyebrowsVariant { get; set; } = "";
    public string BlushVariant { get; set; } = "";
    public string SpecialVariant { get; set; } = "";
}
```

---

## ?? 美术资源制作指南

### 整图替换模式
```
1. 准备 1080x1920 的 PNG 文件
2. 绘制完整的人物立绘（每个表情一张）
3. 命名为: happy.png, sad.png, angry.png ...
4. 放入 Textures/UI/Narrators/9x16/{PersonaName}/full/
```

### 面部覆盖模式
```
1. 基础立绘 (base.png): 完整人物，中性表情
2. 面部层 (XXX_face.png): 
   - 只包含面部区域
   - 透明背景
   - 尺寸与基础立绘一致
   - 面部位置对准基础立绘
3. 放入 Textures/UI/Narrators/9x16/{PersonaName}/face/
```

### 分层合成模式 ?
```
1. 基础立绘 (base.png): 身体、背景、头发等不变部分
2. 眼睛层 (eyes_*.png):
   - 仅包含眼睛部分
   - 透明背景
   - 位置对准基础立绘
   - 变体: neutral, happy, sad, angry, surprised, closed
3. 嘴巴层 (mouth_*.png):
   - 仅包含嘴巴部分
   - 透明背景
   - 变体: neutral, smile, frown, open, smirk
4. 眉毛层 (eyebrows_*.png):
   - 仅包含眉毛部分
   - 透明背景
   - 变体: normal, raised, angry, worried
5. 放入 Textures/UI/Narrators/9x16/{PersonaName}/layers/
```

### Photoshop/GIMP 工作流程
```
1. 创建 1080x1920 画布
2. 图层结构:
   ├─ 特殊效果层 (可选)
   ├─ 眉毛层
   ├─ 眼睛层
   ├─ 嘴巴层
   ├─ 腮红层 (可选)
   └─ 基础层 (身体、背景)

3. 导出流程:
   - 隐藏所有表情层 → 导出 base.png
   - 仅显示眼睛层 → 导出 eyes_happy.png
   - 仅显示嘴巴层 → 导出 mouth_smile.png
   - ...
```

---

## ?? 配置与使用

### PersonaDef 配置

```xml
<NarratorPersonaDef>
  <defName>Cassandra_9x16</defName>
  <label>Cassandra (竖版)</label>
  
  <!-- 指定使用竖版立绘 -->
  <portraitPath>UI/Narrators/9x16/Cassandra/base</portraitPath>
  
  <!-- 表情模式配置 -->
  <expressionMode>LayeredComposition</expressionMode>
  
  <!-- 面部区域配置 (可选，有默认值) -->
  <faceRegion>
    <centerX>0.5</centerX>
    <centerY>0.25</centerY>
    <width>0.6</width>
    <height>0.2</height>
  </faceRegion>
  
  <!-- 分层区域配置 (可选) -->
  <layerRegions>
    <eyes>
      <centerX>0.5</centerX>
      <centerY>0.4</centerY>
      <width>0.8</width>
      <height>0.3</height>
    </eyes>
    <mouth>
      <centerX>0.5</centerX>
      <centerY>0.75</centerY>
      <width>0.5</width>
      <height>0.25</height>
    </mouth>
  </layerRegions>
</NarratorPersonaDef>
```

### C# 代码使用

```csharp
// 加载竖版立绘
var portrait = PortraitLoader.LoadPortrait_9x16(personaDef, ExpressionType.Happy);

// 切换表情
ExpressionSystem.SetExpression("Cassandra_9x16", ExpressionType.Sad);

// 获取当前表情的立绘
var currentPortrait = PortraitLoader.LoadPortrait(
    personaDef, 
    ExpressionSystem.GetExpressionState("Cassandra_9x16").CurrentExpression
);
```

---

## ?? 性能优化

### 缓存策略
```csharp
// 缓存基础立绘
private static Dictionary<string, Texture2D> baseTextureCache;

// 缓存分层纹理
private static Dictionary<string, Texture2D> layerTextureCache;

// 缓存合成结果
private static Dictionary<string, Texture2D> compositeCache;

// 缓存键格式
string cacheKey = $"{personaName}_{aspectRatio}_{expression}_{layers}";
```

### 内存管理
```csharp
// 定期清理未使用的缓存
public static void CleanupUnusedCache(float unusedTimeThreshold = 300f)
{
    var now = Time.realtimeSinceStartup;
    
    foreach (var key in cacheAccessTime.Keys.ToList())
    {
        if (now - cacheAccessTime[key] > unusedTimeThreshold)
        {
            // 清理缓存
            if (compositeCache.TryGetValue(key, out Texture2D tex))
            {
                UnityEngine.Object.Destroy(tex);
                compositeCache.Remove(key);
            }
        }
    }
}
```

### 异步加载
```csharp
// 预加载常用表情
public static async Task PreloadExpressions(string personaName)
{
    var commonExpressions = new[] 
    {
        ExpressionType.Neutral,
        ExpressionType.Happy,
        ExpressionType.Sad,
        ExpressionType.Angry
    };
    
    foreach (var expr in commonExpressions)
    {
        await Task.Run(() =>
        {
            LoadPortrait_9x16(personaDef, expr);
        });
    }
}
```

---

## ? 兼容性保证

### 横版/竖版自动切换
```csharp
public static Texture2D LoadPortraitAuto(NarratorPersonaDef def, ExpressionType expression)
{
    // 检测是否有竖版立绘
    if (Has9x16Portrait(def.defName))
    {
        var portrait = LoadPortrait_9x16(def, expression);
        if (portrait != null) return portrait;
    }
    
    // 回退到横版立绘
    return LoadPortrait(def, expression);
}
```

### 向后兼容
```csharp
// 旧代码继续工作
var oldPortrait = PortraitLoader.LoadPortrait(def, expression);

// 新代码支持竖版
var newPortrait = PortraitLoader.LoadPortrait_9x16(def, expression);
```

---

## ?? 测试清单

- [ ] 横版立绘正常加载
- [ ] 竖版立绘正常加载
- [ ] 整图替换模式工作正常
- [ ] 面部覆盖模式工作正常
- [ ] 分层合成模式工作正常
- [ ] 表情切换流畅
- [ ] 缓存系统有效
- [ ] 内存不泄漏
- [ ] 性能在可接受范围
- [ ] 向后兼容

---

## ?? 实现优先级

### 第一阶段 (必须)
1. ? 竖版立绘基础加载
2. ? 纵横比自动检测
3. ? 整图替换模式
4. ? 面部覆盖模式

### 第二阶段 (推荐)
5. ? 分层合成模式
6. ? 缓存优化
7. ? 异步加载

### 第三阶段 (可选)
8. ?? 表情动画过渡
9. ?? 自定义层叠顺序
10. ?? 实时表情编辑器

---

## ?? 参考资源

- [Unity Texture2D 文档](https://docs.unity3d.com/ScriptReference/Texture2D.html)
- [Alpha 混合算法](https://en.wikipedia.org/wiki/Alpha_compositing)
- [Photoshop 图层导出](https://helpx.adobe.com/photoshop/using/export-artboards-layers.html)
- [GIMP 图层教程](https://docs.gimp.org/en/gimp-image-combining.html)

---

## ?? 示例资源

### 最小化测试资源
```
Textures/UI/Narrators/9x16/TestPersona/
├─ base.png                    # 1080x1920, 基础立绘
├─ full/
│  └─ happy.png                # 1080x1920, 完整开心表情
├─ face/
│  └─ happy_face.png           # 1080x1920, 开心面部
└─ layers/
   ├─ eyes_happy.png           # 1080x1920, 开心眼睛
   ├─ mouth_smile.png          # 1080x1920, 微笑嘴巴
   └─ eyebrows_raised.png      # 1080x1920, 扬起眉毛
```

---

## ?? 快速开始

### 1. 准备竖版立绘
```bash
# 创建目录
mkdir -p Textures/UI/Narrators/9x16/MyPersona/layers

# 准备文件
- base.png (1080x1920)
- layers/eyes_neutral.png
- layers/eyes_happy.png
- layers/mouth_neutral.png
- layers/mouth_smile.png
```

### 2. 配置 PersonaDef
```xml
<NarratorPersonaDef>
  <defName>MyPersona_9x16</defName>
  <portraitPath>UI/Narrators/9x16/MyPersona/base</portraitPath>
  <expressionMode>LayeredComposition</expressionMode>
</NarratorPersonaDef>
```

### 3. 代码中使用
```csharp
// 加载立绘
var portrait = PortraitLoader.LoadPortrait_9x16(def, ExpressionType.Happy);

// 切换表情
ExpressionSystem.SetExpression(def.defName, ExpressionType.Sad);
```

---

**设计完成时间**: 2025-01-XX  
**作者**: AI Assistant  
**版本**: v1.0
