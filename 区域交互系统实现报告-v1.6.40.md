# 区域交互系统实现报告 - v1.6.40

## ?? 实现目标

为 `FullBodyPortraitPanel` 类添加**基于区域的交互系统**，支持：
1. **头部摸摸**：在头部区域摩擦鼠标累积进度
2. **身体戳戳**：单击身体不透明区域触发互动
3. **输入拦截**：防止点击穿透到游戏地图

---

## ? 核心实现

### 1. **InteractionZone 枚举**

```csharp
/// <summary>
/// ? v1.6.40: 交互区域枚举
/// </summary>
private enum InteractionZone
{
    None,   // 无交互区域
    Head,   // 头部区域（上方25%）
    Body    // 身体区域（其余部分，需不透明像素检测）
}
```

**作用**：定义立绘的可交互区域类型。

---

### 2. **GetInteractionZone 方法**

```csharp
/// <summary>
/// ? v1.6.40: 获取交互区域
/// </summary>
private InteractionZone GetInteractionZone(Rect rect, Vector2 mousePos)
{
    if (!rect.Contains(mousePos))
    {
        return InteractionZone.None;
    }
    
    // 计算相对位置（0-1）
    float relativeY = (mousePos.y - rect.y) / rect.height;
    
    // ? 头部区域：上方 25%
    if (relativeY < 0.25f)
    {
        return InteractionZone.Head;
    }
    
    // ? 身体区域：其余部分，需要不透明像素检测
    if (IsOpaquePixel(rect, mousePos))
    {
        return InteractionZone.Body;
    }
    
    return InteractionZone.None;
}
```

**逻辑**：
- **头部区域**：`relativeY < 0.25f`（立绘上方 25%）
- **身体区域**：剩余部分 + 不透明像素检测

---

### 3. **IsOpaquePixel 方法（简化版本）**

```csharp
/// <summary>
/// ? v1.6.40: 检测像素是否不透明（简化版本）
/// 注意：完整实现需要访问纹理像素数据，这里使用简化判断
/// </summary>
private bool IsOpaquePixel(Rect rect, Vector2 mousePos)
{
    // ? 简化实现：假设立绘中心80%区域都是不透明的
    // 完整实现需要：baseBody.GetPixel(x, y).a > 0.1f
    
    float relativeX = (mousePos.x - rect.x) / rect.width;
    float relativeY = (mousePos.y - rect.y) / rect.height;
    
    // 排除边缘10%区域（通常是透明的）
    bool inCentralArea = relativeX > 0.1f && relativeX < 0.9f &&
                        relativeY > 0.1f && relativeY < 0.9f;
    
    return inCentralArea;
}
```

**简化原因**：
- 完整实现需要读取纹理像素 alpha 通道（`Texture2D.GetPixel()`）
- 这需要纹理设置为 `Read/Write Enabled`，可能影响性能
- 简化版本使用**中心区域判断**（排除边缘 10%）

**未来改进**：
```csharp
// 完整实现（需要 Read/Write Enabled 纹理）
var baseBody = PortraitLoader.GetLayerTexture(currentPersona, "base_body");
if (baseBody != null && baseBody.isReadable)
{
    int x = (int)((mousePos.x - rect.x) / rect.width * baseBody.width);
    int y = (int)((mousePos.y - rect.y) / rect.height * baseBody.height);
    Color pixel = baseBody.GetPixel(x, y);
    return pixel.a > 0.1f;  // alpha > 10% 为不透明
}
```

---

### 4. **头部摸摸逻辑（摩擦累积）**

#### 相关字段

```csharp
private float headRubProgress = 0f;
private const float HEAD_RUB_THRESHOLD = 60f;
private const float HEAD_RUB_DECAY_RATE = 20f;  // 每秒衰减速度
private float lastHeadPatTime = 0f;
private const float HEAD_PAT_COOLDOWN = 3.0f;
```

#### 核心逻辑

```csharp
// ? 1. 处理头部摸摸逻辑（摩擦累积）
if (zone == InteractionZone.Head)
{
    // ? 检测鼠标拖拽或移动（左键按下时）
    bool isMouseDragging = (Event.current.type == EventType.MouseDrag) || 
                          (Event.current.type == EventType.MouseMove && Event.current.button == 0);
    
    if (isMouseDragging)
    {
        // 鼠标在头部区域移动时累积进度
        float moveDistance = Vector2.Distance(mousePos, lastMousePosition);
        headRubProgress += moveDistance * 0.5f;  // 移动距离转换为进度
        
        if (headRubProgress >= HEAD_RUB_THRESHOLD)
        {
            float currentTime = Time.realtimeSinceStartup;
            if (currentTime - lastHeadPatTime >= HEAD_PAT_COOLDOWN)
            {
                DoHeadPatInteraction();
                headRubProgress = 0f;
                lastHeadPatTime = currentTime;
                
                Event.current.Use();  // ? 拦截事件，防止穿透
                return true;
            }
        }
        
        lastMousePosition = mousePos;
    }
    else if (Event.current.type == EventType.MouseDown)
    {
        lastMousePosition = mousePos;
    }
}
else
{
    // 不在头部时衰减进度
    if (headRubProgress > 0f)
    {
        headRubProgress -= HEAD_RUB_DECAY_RATE * Time.deltaTime;
        if (headRubProgress < 0f) headRubProgress = 0f;
    }
}
```

**工作原理**：
1. **累积进度**：鼠标在头部移动时，累积 `移动距离 × 0.5`
2. **触发条件**：进度 ≥ 60 且冷却时间 ≥ 3 秒
3. **衰减机制**：离开头部区域后，进度以 20/秒 的速度衰减
4. **输入拦截**：触发时调用 `Event.current.Use()` 防止穿透

---

### 5. **身体戳戳逻辑（单击检测）**

```csharp
// ? 2. 处理身体戳戳逻辑（单击检测）
if (zone == InteractionZone.Body)
{
    if (Event.current.type == EventType.MouseDown && Event.current.button == 0)
    {
        DoPokeInteraction();
        Event.current.Use();  // ? 拦截事件，防止穿透
        return true;
    }
}
```

**工作原理**：
1. **触发条件**：左键单击 + 在身体不透明区域
2. **即时触发**：无需累积，单击即触发
3. **输入拦截**：触发时调用 `Event.current.Use()` 防止穿透

---

### 6. **DoHeadPatInteraction 方法**

```csharp
/// <summary>
/// ? v1.6.40: 头部摸摸互动
/// </summary>
private void DoHeadPatInteraction()
{
    if (currentPersona == null) return;
    
    if (Prefs.DevMode)
    {
        Log.Message("[FullBodyPortraitPanel] 头部摸摸触发！");
    }
    
    // ? 触发害羞或开心表情
    bool isShy = Random.value > 0.5f;
    TriggerExpression(isShy ? ExpressionType.Shy : ExpressionType.Happy, duration: 3f);
    
    // ? 显示浮动文字
    string[] shyTexts = { "(/ω＼)", "(//ω//)", "(〃??`)", "(*ノωノ)" };
    string[] happyTexts = { "(?｀)", "(RQ)", "(*^^*)", "d(?°?°?)?" };
    string text = isShy ? shyTexts[Random.Range(0, shyTexts.Length)] : happyTexts[Random.Range(0, happyTexts.Length)];
    ShowFloatingText(text, isShy ? new Color(1f, 0.6f, 0.6f) : new Color(1f, 0.9f, 0.3f));
    
    // ? 边框闪烁
    StartBorderFlash(1);
    
    // ? 好感度增加
    ModifyAffinity(3f, "头部摸摸互动");
    Messages.Message("好感度 +3（头部摸摸）", MessageTypeDefOf.PositiveEvent);
}
```

**效果**：
- **表情**：50% 害羞 / 50% 开心
- **浮动文字**：随机颜文字
- **好感度**：+3
- **边框闪烁**：1 次慢速闪烁

---

### 7. **DoPokeInteraction 方法**

```csharp
/// <summary>
/// ? v1.6.40: 身体戳戳互动
/// </summary>
private void DoPokeInteraction()
{
    if (currentPersona == null) return;
    
    if (Prefs.DevMode)
    {
        Log.Message("[FullBodyPortraitPanel] 身体戳戳触发！");
    }
    
    // ? 触发惊讶或困惑表情
    bool isSurprised = Random.value > 0.5f;
    TriggerExpression(isSurprised ? ExpressionType.Surprised : ExpressionType.Confused, duration: 2f);
    
    // ? 显示浮动文字
    string[] surprisedTexts = { "(?ω?)?", "Σ(っ °Д °;)っ", "(⊙o⊙)", "(°ロ°) !" };
    string[] confusedTexts = { "(?_??)", "(??_?`)", "(￣ω￣;)", "( ?_f`)" };
    string text = isSurprised ? surprisedTexts[Random.Range(0, surprisedTexts.Length)] : confusedTexts[Random.Range(0, confusedTexts.Length)];
    ShowFloatingText(text, new Color(0.8f, 0.9f, 1f));
    
    // ? 好感度轻微增加
    ModifyAffinity(1f, "身体戳戳互动");
}
```

**效果**：
- **表情**：50% 惊讶 / 50% 困惑
- **浮动文字**：随机颜文字
- **好感度**：+1（比头部摸摸少）

---

### 8. **进度条显示**

```csharp
/// <summary>
/// ? v1.6.40: 绘制头部摸摸进度条
/// </summary>
private void DrawHeadRubProgress(Rect inRect, float progress)
{
    progress = Mathf.Clamp01(progress);
    
    // 在立绘上方显示进度条
    var progressBarRect = new Rect(inRect.x, inRect.y - 12f, inRect.width, 8f);
    Widgets.DrawBoxSolid(progressBarRect, new Color(0.2f, 0.2f, 0.2f, 0.6f));
    
    var fillRect = new Rect(progressBarRect.x, progressBarRect.y, progressBarRect.width * progress, progressBarRect.height);
    Color fillColor = Color.Lerp(new Color(1f, 0.6f, 0.6f), new Color(1f, 0.3f, 0.3f), progress);
    Widgets.DrawBoxSolid(fillRect, fillColor);
    
    // 显示文字提示
    if (progress > 0.5f)
    {
        Text.Font = GameFont.Tiny;
        Text.Anchor = TextAnchor.MiddleCenter;
        GUI.color = new Color(1f, 1f, 1f, 0.8f);
        Widgets.Label(progressBarRect, "继续摸摸...");
        Text.Anchor = TextAnchor.UpperLeft;
        GUI.color = Color.white;
    }
}
```

**效果**：
- 位置：立绘上方 12 像素
- 颜色：从浅粉色渐变到深粉色
- 提示：进度 > 50% 时显示"继续摸摸..."

---

### 9. **Tooltip 增强**

```csharp
// ? v1.6.40: 显示当前交互区域
var zone = GetInteractionZone(inRect, Event.current.mousePosition);
if (zone == InteractionZone.Head)
{
    tooltip += $"\n\n?? 头部区域 | 摸摸进度: {headRubProgress:F0}/{HEAD_RUB_THRESHOLD}";
}
else if (zone == InteractionZone.Body)
{
    tooltip += "\n\n?? 身体区域 | 单击戳戳";
}
```

**效果**：
- 悬停头部：显示摸摸进度
- 悬停身体：提示单击戳戳

---

## ?? 交互对比

| 交互类型 | 触发方式 | 累积机制 | 冷却时间 | 好感度 | 表情 |
|---------|---------|---------|---------|--------|------|
| **头部摸摸** | 摩擦鼠标累积 60 点 | ? 累积 + 衰减 | 3 秒 | +3 | 害羞/开心 |
| **身体戳戳** | 单击 | ? 即时触发 | 无 | +1 | 惊讶/困惑 |
| **触摸模式** | 悬停 1 秒激活 | ? 悬停累积 | 无 | +5（连击） | 多种随机 |

---

## ?? 技术亮点

### 1. **输入拦截机制**

```csharp
Event.current.Use();  // ? 拦截事件，防止穿透
```

**作用**：
- 防止点击立绘时穿透到游戏地图
- 防止意外点击地面导致镜头移动

---

### 2. **进度衰减机制**

```csharp
// 不在头部时衰减进度
if (headRubProgress > 0f)
{
    headRubProgress -= HEAD_RUB_DECAY_RATE * Time.deltaTime;
    if (headRubProgress < 0f) headRubProgress = 0f;
}
```

**作用**：
- 离开头部区域后，进度自动衰减
- 避免进度长时间残留
- 鼓励连续摩擦

---

### 3. **冷却机制**

```csharp
float currentTime = Time.realtimeSinceStartup;
if (currentTime - lastHeadPatTime >= HEAD_PAT_COOLDOWN)
{
    DoHeadPatInteraction();
    lastHeadPatTime = currentTime;
}
```

**作用**：
- 防止连续触发（3 秒冷却）
- 避免好感度增长过快
- 提升交互体验

---

### 4. **优先级系统**

```csharp
// ? v1.6.40: 处理区域交互（优先级高于旧触摸系统）
bool zoneInteractionHandled = HandleZoneInteraction(inRect);

// ? v1.6.25: 处理触摸互动（如果区域交互未处理）
if (!zoneInteractionHandled)
{
    HandleHoverAndTouch(inRect);
}
```

**作用**：
- 区域交互优先级高于旧触摸系统
- 避免多个系统冲突
- 保持向后兼容

---

## ?? 测试场景

### 场景 1：头部摸摸

**操作**：
1. 鼠标移到立绘上方 25% 区域（头部）
2. 按住左键并摩擦鼠标
3. 观察进度条上升（立绘上方）
4. 进度达到 60 时触发互动

**预期效果**：
- ? 进度条实时显示
- ? 进度 > 50% 时显示"继续摸摸..."
- ? 触发时：表情变为害羞/开心
- ? 浮动文字：`(/ω＼)` 或 `(?｀)`
- ? 好感度 +3
- ? 边框慢速闪烁 1 次

---

### 场景 2：头部摸摸冷却

**操作**：
1. 触发头部摸摸
2. 立即再次摩擦头部（进度累积到 60）
3. 观察是否触发

**预期效果**：
- ? 不触发（3 秒冷却中）
- ? 进度条显示但不触发互动

---

### 场景 3：身体戳戳

**操作**：
1. 鼠标移到立绘中心区域（身体）
2. 单击鼠标左键

**预期效果**：
- ? 表情变为惊讶/困惑
- ? 浮动文字：`(?ω?)?` 或 `(??_?`)`
- ? 好感度 +1
- ? 无边框闪烁

---

### 场景 4：输入拦截

**操作**：
1. 点击立绘（头部或身体区域）
2. 观察是否穿透到游戏地图

**预期效果**：
- ? 不穿透到地图
- ? 不触发镜头移动
- ? 只触发立绘互动

---

### 场景 5：进度衰减

**操作**：
1. 在头部摩擦鼠标（进度累积到 30）
2. 鼠标移出立绘区域
3. 观察进度条

**预期效果**：
- ? 进度以 20/秒 速度衰减
- ? 进度条逐渐缩短
- ? 进度归零后进度条消失

---

## ?? 代码结构

```
FullBodyPortraitPanel.cs
├── InteractionZone 枚举
│   ├── None
│   ├── Head
│   └── Body
│
├── 字段
│   ├── headRubProgress        // 摸摸进度
│   ├── HEAD_RUB_THRESHOLD     // 触发阈值 60
│   ├── HEAD_RUB_DECAY_RATE    // 衰减速度 20/s
│   ├── lastHeadPatTime        // 上次触发时间
│   └── HEAD_PAT_COOLDOWN      // 冷却时间 3s
│
├── 核心方法
│   ├── HandleZoneInteraction()       // 区域交互主逻辑
│   ├── GetInteractionZone()          // 检测交互区域
│   ├── IsOpaquePixel()               // 不透明像素检测
│   ├── DoHeadPatInteraction()        // 头部摸摸效果
│   ├── DoPokeInteraction()           // 身体戳戳效果
│   └── DrawHeadRubProgress()         // 进度条绘制
│
└── DoWindowContents()
    ├── HandleZoneInteraction()       // 优先
    └── HandleHoverAndTouch()         // 回退
```

---

## ?? 部署状态

| 项目 | 状态 |
|------|------|
| **代码实现** | ? 完成 |
| **编译** | ? 成功（0 错误，2 警告） |
| **部署** | ? 已部署到 RimWorld Mods 文件夹 |
| **测试** | ?? 待游戏内测试 |

---

## ?? 未来改进

### ?? 建议的增强

1. **完整不透明像素检测**
   ```csharp
   // 使用 Texture2D.GetPixel() 精确检测
   var baseBody = PortraitLoader.GetLayerTexture(currentPersona, "base_body");
   if (baseBody != null && baseBody.isReadable)
   {
       int x = (int)((mousePos.x - rect.x) / rect.width * baseBody.width);
       int y = (int)((mousePos.y - rect.y) / rect.height * baseBody.height);
       return baseBody.GetPixel(x, y).a > 0.1f;
   }
   ```

2. **更多交互区域**
   - 脸颊区域（戳戳脸蛋）
   - 手部区域（握手）
   - 尾巴区域（如果有尾巴）

3. **连击系统**
   - 连续头部摸摸触发特殊动画
   - 连续戳戳触发生气表情

4. **音效反馈**
   - 头部摸摸：柔和的音效
   - 身体戳戳：轻快的音效

---

## ?? 总结

### 核心成就

? **区域交互系统**
- 头部摸摸：摩擦累积 + 进度显示
- 身体戳戳：单击即时触发
- 输入拦截：防止穿透

? **进度机制**
- 累积：移动距离 × 0.5
- 衰减：20/秒
- 冷却：3 秒

? **用户体验**
- 实时进度条显示
- Tooltip 区域提示
- 浮动文字反馈

? **向后兼容**
- 保留旧触摸系统
- 优先级明确
- 无冲突

---

**版本**: v1.6.40  
**状态**: ? 已编译、已部署

?? **区域交互系统实现完成！** ??
